-- IT・ソフトウェア開発プロジェクトマネジメントコース
-- Lesson 5: アーキテクチャ設計とレビュー手法

DO $$
DECLARE
  v_course_id INT;
  v_lesson_id INT;
BEGIN
  -- Get course ID
  SELECT id INTO v_course_id FROM courses WHERE slug = 'it-software-pm';

  -- Lesson 5: アーキテクチャ設計とレビュー手法
  INSERT INTO lessons (course_id, slug, title, content, "order", created_at)
  VALUES (
    v_course_id,
    'architecture-design-review',
    'アーキテクチャ設計とレビュー手法',
    $CONTENT$# アーキテクチャ設計とレビュー手法

ソフトウェアアーキテクチャは、**システムの基本構造を定義し、非機能要件を実現するための重要な設計判断**です。

## アーキテクチャの役割と重要性

### アーキテクチャが扱う関心事

| 関心事 | 内容 | 例 |
|-------|------|---|
| **構造** | システムの構成要素と関係 | レイヤー構造、モジュール分割 |
| **品質特性** | 非機能要件の実現 | 性能、可用性、保守性 |
| **技術選定** | 使用する技術とフレームワーク | 言語、DB、インフラ |
| **制約条件** | 設計上の制約 | レガシー連携、予算、期間 |

### アーキテクチャの設計判断が影響する範囲

- 🎯 **性能・スケーラビリティ** - 後から変更が困難
- 🛡️ **セキュリティ** - 構造に組み込む必要
- 🔧 **保守性・拡張性** - 長期的なコストに影響
- 💰 **開発コスト** - 技術選定が工数を左右
- ⏱️ **開発期間** - アーキテクチャの複雑さが影響

## 主要なアーキテクチャパターン

### 1. レイヤードアーキテクチャ（階層化）

**構造：**
```
プレゼンテーション層（UI）
        ↓
   ビジネス層（ロジック）
        ↓
   データアクセス層（永続化）
        ↓
    データベース
```

**特徴：**
- ✅ 関心の分離が明確
- ✅ 各層の独立したテストが可能
- ✅ 理解しやすく習得容易
- ⚠️ 性能オーバーヘッドの可能性

**適用場面：**
- 📊 業務システム、エンタープライズアプリ
- 🏢 明確な責務分離が必要な場合

### 2. マイクロサービスアーキテクチャ

**構造：**
- 🔹 小さな独立したサービスの集合
- 🔹 各サービスが独自のDBを持つ
- 🔹 API（REST/gRPC）で通信
- 🔹 独立したデプロイ・スケーリング

**利点：**
- ✅ 独立した開発・デプロイ
- ✅ 技術スタックの柔軟性
- ✅ 障害の局所化
- ✅ スケーラビリティ

**課題：**
- ⚠️ 分散システムの複雑性
- ⚠️ データ整合性の管理
- ⚠️ 運用コストの増加
- ⚠️ デバッグの困難さ

**適用場面：**
- 📱 大規模Webサービス
- 🔄 頻繁な変更が必要
- 👥 複数チームでの並行開発

### 3. イベント駆動アーキテクチャ

**構造：**
- 📨 イベントの生成・配信・消費
- 🔄 疎結合なコンポーネント連携
- 📊 イベントストア（履歴管理）

**パターン：**

| パターン | 説明 | 用途 |
|---------|------|------|
| **Pub/Sub** | パブリッシャーとサブスクライバー | 通知、ログ集約 |
| **Event Sourcing** | イベント履歴がデータの源泉 | 監査、時系列分析 |
| **CQRS** | コマンドとクエリを分離 | 読み書き負荷が異なる |

**適用場面：**
- 📈 リアルタイム処理
- 🔄 非同期処理が多い
- 📊 イベント履歴の追跡が重要

### 4. ヘキサゴナルアーキテクチャ（ポート&アダプター）

**構造：**
```
      外部システム・UI
           ↓
      アダプター（実装）
           ↓
      ポート（インターフェース）
           ↓
      ドメインロジック（中心）
```

**特徴：**
- 🎯 ビジネスロジックを中心に配置
- 🔌 外部依存を抽象化
- ✅ テスト容易性が高い
- 🔄 外部システムの差し替えが容易

**適用場面：**
- 🎯 ドメイン駆動設計（DDD）
- 🧪 テスト駆動開発（TDD）
- 🔄 外部依存が多い

### 5. サーバーレスアーキテクチャ

**構造：**
- ⚡ FaaS（Function as a Service）
- 📊 マネージドサービスの活用
- 🔄 イベントトリガー

**利点：**
- 💰 従量課金（使った分だけ）
- 🚀 インフラ管理不要
- ⚡ 自動スケーリング

**課題：**
- ⚠️ コールドスタートの遅延
- ⚠️ ベンダーロックイン
- ⚠️ デバッグの困難さ
- ⚠️ 実行時間の制限

## 非機能要件とアーキテクチャの関係

### 性能・スケーラビリティの実現

#### スケーリング戦略

| 戦略 | 説明 | 適用例 |
|------|------|--------|
| **垂直スケーリング** | サーバーのスペックアップ | DB、単一サーバー |
| **水平スケーリング** | サーバー台数を増やす | Webサーバー、APIサーバー |
| **キャッシング** | 頻繁なデータをメモリに | Redis、CDN |
| **非同期処理** | 重い処理をバックグラウンド化 | ジョブキュー |

#### パフォーマンス設計

- 🚀 **レスポンス時間最適化：** CDN、キャッシュ、クエリ最適化
- 📊 **スループット向上：** 並列処理、ロードバランシング
- 💾 **リソース効率：** コネクションプール、メモリ管理

### 可用性・信頼性の実現

#### 冗長化とフェイルオーバー

```
ロードバランサー
    ↓
[Web1] [Web2] [Web3]  ← 冗長化
    ↓
[App1] [App2] [App3]  ← 冗長化
    ↓
[DB Primary] → [DB Standby]  ← レプリケーション
```

**手法：**
- 🔄 **アクティブ-アクティブ:** 全サーバーが稼働
- 🔄 **アクティブ-スタンバイ:** 主系障害時に待機系へ
- 📊 **ヘルスチェック:** 障害検知と自動切り替え

#### 障害対策パターン

| パターン | 説明 | 効果 |
|---------|------|------|
| **サーキットブレーカー** | 障害サービスへのアクセス遮断 | 障害の連鎖防止 |
| **リトライ** | 失敗時の再試行 | 一時的障害の吸収 |
| **タイムアウト** | 応答待ちの時間制限 | リソース枯渇防止 |
| **フォールバック** | 障害時の代替処理 | 縮退運転 |

### セキュリティの実現

#### 多層防御（Defense in Depth）

1. **ネットワーク層**
   - 🛡️ ファイアウォール、WAF
   - 🔒 VPN、プライベートネットワーク

2. **アプリケーション層**
   - 🔐 認証・認可（OAuth2.0、JWT）
   - ✅ 入力検証、サニタイズ
   - 🔒 暗号化（TLS、AES）

3. **データ層**
   - 💾 データ暗号化（保存時・転送時）
   - 📝 監査ログ
   - 🚫 最小権限の原則

#### セキュリティバイデザイン

- 🎯 **設計段階からセキュリティを組み込む**
- ✅ 後付けではなく、アーキテクチャレベルで対策
- 🔍 脅威モデリング（STRIDE）の実施

## アーキテクチャレビュー手法

### レビューの種類

#### 1. 形式的技術レビュー（FTR）

**プロセス：**
1. 📋 レビュー資料の事前配布
2. 👥 レビューミーティング（2-4時間）
3. 📝 指摘事項の記録
4. ✅ フォローアップと承認

**役割：**
- 📋 **モデレーター:** 進行管理
- 👤 **設計者:** 説明責任
- 🔍 **レビュアー:** 指摘・質問
- 📝 **記録者:** 議事録作成

#### 2. ウォークスルー

**特徴：**
- 👤 設計者が主導
- 📊 シナリオに沿って説明
- 💬 非形式的な議論
- 🎯 理解促進と欠陥発見

#### 3. インスペクション

**特徴：**
- 📋 最も形式的なレビュー
- 🔍 チェックリストに基づく検査
- 📊 メトリクス収集
- ✅ 欠陥検出率が高い

**プロセス：**
1. 計画
2. 概要説明
3. 個人チェック
4. ミーティング
5. フォローアップ

### アーキテクチャ評価手法

#### ATAM（Architecture Tradeoff Analysis Method）

**目的：** アーキテクチャのトレードオフ分析

**ステップ：**
1. 📋 ビジネスドライバーの提示
2. 🏗️ アーキテクチャの提示
3. 🎯 品質属性の特定
4. 🔍 アーキテクチャアプローチの分析
5. ⚖️ トレードオフの特定
6. 🚨 リスクの特定

**成果物：**
- ✅ 感度ポイント（変更の影響が大きい箇所）
- ⚠️ トレードオフポイント（相反する品質特性）
- 🚨 リスク一覧

#### ADR（Architecture Decision Record）

**目的：** 重要な設計判断の記録

**テンプレート：**
```
# タイトル: [決定事項]

## ステータス: 承認済み / 提案中 / 却下

## 文脈
なぜこの決定が必要か

## 決定内容
何を決めたか

## 結果
この決定による影響

## 代替案
検討した他の選択肢

## トレードオフ
利点と欠点
```

## レビューで確認すべきポイント

### チェックリスト

#### 1. 要件の充足

- ✅ 機能要件が実現可能か
- ✅ 非機能要件（性能・可用性・セキュリティ）を満たすか
- ✅ 制約条件（予算・期間・技術）に適合するか

#### 2. 設計品質

| 観点 | 確認内容 |
|------|----------|
| **凝集度** | モジュール内の関連性が高いか |
| **結合度** | モジュール間の依存が低いか |
| **単純性** | 不必要な複雑さがないか |
| **拡張性** | 将来の変更に対応できるか |

#### 3. 技術的リスク

- 🚨 **技術的実現可能性:** 未経験技術の採用リスク
- 📊 **パフォーマンスリスク:** 負荷試験の計画
- 🔒 **セキュリティリスク:** 脆弱性の検討
- 🔗 **統合リスク:** 外部システム連携の複雑性

#### 4. 保守性・運用性

- 🔧 **監視・ログ:** 運用時の可観測性
- 🔄 **デプロイ:** CI/CDの実現性
- 📚 **ドキュメント:** 保守のための情報
- 🧪 **テスト戦略:** テストの自動化可能性

## アーキテクチャの進化と技術的負債

### 技術的負債の管理

**技術的負債とは：**
- ⏱️ 短期的な開発速度のために、長期的な品質を犠牲にすること
- 💰 将来の変更コストが増加（利息）

**発生原因：**
- 🚀 **意図的負債:** スピード優先の判断
- 😓 **偶発的負債:** 設計・実装の誤り
- 📚 **時代遅れ負債:** 技術の陳腐化

**管理戦略：**
1. 📊 **可視化:** 負債の記録と影響度評価
2. 💰 **予算確保:** リファクタリング時間の確保
3. 🎯 **優先順位付け:** 影響度の高い負債から対応
4. 🚫 **予防:** レビューによる負債の発生防止

💡 **アーキテクチャは一度決めたら終わりではなく、継続的に進化させるものです。定期的なレビューと評価により、ビジネス要件の変化や技術の進化に対応し、技術的負債を管理しながらシステムの健全性を保ちます。**$CONTENT$,
    5,
    NOW()
  ) RETURNING id INTO v_lesson_id;

  -- Lesson 5: Questions (ひっかけ問題スタイル)
  INSERT INTO questions (lesson_id, type, question, options, correct_answer, explanation, "order", created_at)
  VALUES
    (v_lesson_id, 'multiple-choice', 'マイクロサービスアーキテクチャを採用する最も重要な判断基準はどれですか？',
     ARRAY['最新の技術トレンドであり、採用することでエンジニアの採用に有利', '複数チームでの独立した開発・デプロイが必要で、その価値が複雑性のコストを上回る', 'モノリシックアーキテクチャよりも常に性能とスケーラビリティが優れている', 'システムの規模が大きいため、マイクロサービス化が必須'],
     ARRAY['複数チームでの独立した開発・デプロイが必要で、その価値が複雑性のコストを上回る'],
     'A、C、Dは誤った判断基準です。Aのトレンドや採用は副次的メリット、Cは誤解（マイクロサービスは分散システムのオーバーヘッドがある）、Dの規模だけでは理由不十分です。マイクロサービスは「分散システムの複雑性」というコストを払うため、Bのように「独立性の価値がコストを上回る」場合にのみ採用すべきです。アーキテクチャ選択は常にトレードオフです。',
     1, NOW()),
    (v_lesson_id, 'multiple-answer', 'システムの可用性99.9%を実現するために必要なアーキテクチャ要素を全て選択してください。',
     ARRAY['サーバーの冗長化とロードバランシング', 'データベースのレプリケーションとフェイルオーバー', '高性能なサーバーの採用による処理速度の向上', 'ヘルスチェックと自動復旧の仕組み'],
     ARRAY['サーバーの冗長化とロードバランシング', 'データベースのレプリケーションとフェイルオーバー', 'ヘルスチェックと自動復旧の仕組み'],
     '可用性は「システムが利用可能な時間の割合」です。A、B、Dは単一障害点を排除し、障害時の自動復旧を実現するため可用性向上に寄与します。しかしCの「高性能サーバー」は処理速度（性能）の向上であり、可用性とは別の品質特性です。高性能でも1台だけなら障害時にダウンします。可用性は冗長性と障害対策であり、性能とは異なる設計アプローチが必要です。',
     2, NOW()),
    (v_lesson_id, 'multiple-choice', 'ATAM（Architecture Tradeoff Analysis Method）で「トレードオフポイント」を特定する目的として最も適切なのはどれですか？',
     ARRAY['アーキテクチャの欠陥を全て洗い出し、修正する', '相反する品質特性を明確にし、優先順位に基づいた設計判断を支援する', 'アーキテクチャの実装コストを見積もり、予算内に収める', '最も優れたアーキテクチャパターンを選定する'],
     ARRAY['相反する品質特性を明確にし、優先順位に基づいた設計判断を支援する'],
     'ATAMの本質は「トレードオフの可視化」です。Bが正解です。例えば「性能を上げるとコストが増える」「セキュリティを強化すると使いやすさが下がる」などの相反関係を明示し、ビジネス優先度に基づいた判断を支援します。Aは欠陥検出ではなくトレードオフ分析、Cはコスト見積もりが主目的ではない、Dは「最も優れた」という絶対解を求めるものではなく、トレードオフを理解した上での適切な判断が目的です。',
     3, NOW()),
    (v_lesson_id, 'multiple-answer', 'アーキテクチャレビューで「技術的負債」として記録すべき事項を全て選択してください。',
     ARRAY['短期的な納期優先のため、モジュール構造を簡略化し、将来の拡張性を犠牲にした', '最新のフレームワークを採用したが、チームに経験者がいないため学習コストが発生している', 'セキュリティ要件を満たすため、多層防御の設計を採用し、実装が複雑になった', 'ライブラリのバージョンが古く、既知の脆弱性があるが、アップデートの影響範囲が大きいため保留している'],
     ARRAY['短期的な納期優先のため、モジュール構造を簡略化し、将来の拡張性を犠牲にした', 'ライブラリのバージョンが古く、既知の脆弱性があるが、アップデートの影響範囲が大きいため保留している'],
     '技術的負債は「短期的利益のために長期的品質を犠牲にすること」です。AとDが該当します。Bは学習コストであり、適切な技術選定のコストで負債ではありません。Cはセキュリティ要件を満たすための正当な複雑性であり、負債ではなく「必要なコスト」です。負債と「正当な設計判断によるコスト」を混同しないことが重要です。',
     4, NOW()),
    (v_lesson_id, 'multiple-choice', 'ADR（Architecture Decision Record）を作成する最も重要な目的はどれですか？',
     ARRAY['アーキテクチャの承認プロセスを形式化し、責任の所在を明確にする', '将来、なぜその設計判断をしたのかの文脈を残し、変更時の判断材料とする', 'アーキテクチャドキュメントとして、新メンバーへの教育資料にする', 'プロジェクトの進捗報告資料として、ステークホルダーに説明する'],
     ARRAY['将来、なぜその設計判断をしたのかの文脈を残し、変更時の判断材料とする'],
     'ADRの最も重要な目的はBです。設計判断は「その時点の文脈」に基づいており、時間が経つと「なぜそうしたのか」が分からなくなります。ADRは「決定内容」だけでなく「文脈・理由・トレードオフ・代替案」を記録することで、将来の変更時に「この判断は今も妥当か」を評価できます。A、C、Dも副次的効果ですが、本質は「文脈の記録」です。',
     5, NOW());

END $$;
