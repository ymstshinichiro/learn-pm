-- IT・ソフトウェア開発プロジェクトマネジメントコース
-- Private course for authenticated users
-- 各レッスンに初級〜上級の内容が内在、5問ずつ

-- Insert course
INSERT INTO courses (slug, title, category, description, is_public, created_at)
VALUES (
  'it-software-pm',
  'IT・ソフトウェア開発プロジェクトマネジメントコース',
  'IT・ソフトウェア開発',
  'ソフトウェア開発プロジェクトに特化したマネジメント手法を学びます。要件定義、開発モデル、品質保証、リスク管理、アジャイル実践など、ITプロジェクトマネージャーに必要な実践的知識を網羅的に習得します。',
  0,
  NOW()
);

-- Get the course ID
DO $$
DECLARE
  v_course_id INT;
  v_lesson_id INT;
BEGIN
  SELECT id INTO v_course_id FROM courses WHERE slug = 'it-software-pm';

  -- Lesson 1: ITプロジェクトの特徴とライフサイクル理解
  INSERT INTO lessons (course_id, slug, title, content, "order", created_at)
  VALUES (
    v_course_id,
    'it-project-characteristics',
    'ITプロジェクトの特徴とライフサイクル理解',
    '# ITプロジェクトの特徴とライフサイクル理解

ITプロジェクトは、**無形の成果物を扱い、技術的複雑性と変化の速さに対応する必要がある**という特有の性質を持ちます。

## ITプロジェクトの特徴

### 1. 無形性（Intangibility）

ソフトウェアは物理的な形を持たないため、進捗や品質の可視化が困難です。

**課題：**
- 📊 進捗が見えにくい
- 🔍 品質の判断が難しい
- 💬 ステークホルダーとの認識齟齬が起きやすい

**対策：**
- ✅ プロトタイプやモックアップで可視化
- ✅ デモを頻繁に実施
- ✅ 明確な受入基準を設定

### 2. 変化の速さ

技術トレンド、ビジネス要件、規制などが急速に変化します。

**影響：**
- 🔄 要件の変更が頻繁に発生
- 📱 新技術への対応が必要
- ⚡ 短期間での意思決定が求められる

### 3. 技術的複雑性

複数の技術・システムの統合、レガシーシステムとの連携など、技術的な複雑さが高い。

**リスク要因：**
- 🔧 技術的実現可能性の不確実性
- 🔗 システム間連携の複雑さ
- 🛠️ スキル不足による遅延

### 4. 人的要因の重要性

エンジニアのスキル・モチベーション・コミュニケーションが成果に直結します。

## ITプロジェクトのライフサイクル

### 標準的なフェーズ

#### 1. 企画・立案
- 💡 ビジネス課題の特定
- 📋 フィージビリティスタディ
- 💰 投資対効果の評価

#### 2. 要件定義
- 📝 機能要件・非機能要件の明確化
- 👥 ステークホルダーインタビュー
- ✅ 要件の優先順位付け

#### 3. 設計
- 🏗️ アーキテクチャ設計
- 🖼️ UI/UXデザイン
- 🗄️ データベース設計

#### 4. 開発・実装
- 💻 コーディング
- 🔄 単体テスト
- 🔗 統合

#### 5. テスト
- ✅ 結合テスト
- 🧪 システムテスト
- 👤 ユーザー受入テスト（UAT）

#### 6. リリース・移行
- 🚀 本番環境へのデプロイ
- 📚 ドキュメント整備
- 🎓 ユーザートレーニング

#### 7. 運用・保守
- 🔧 障害対応
- 📈 性能監視
- 🔄 機能追加・改善

## フェーズ間のゲート管理

各フェーズの完了時に、**ゲートレビュー**を実施します。

### ゲートレビューの目的

| 確認項目 | 内容 |
|---------|------|
| **成果物完成度** | 必要な成果物が揃っているか |
| **品質基準** | 品質基準を満たしているか |
| **リスク評価** | 次フェーズへ進むリスクは許容範囲か |
| **リソース確保** | 次フェーズのリソースは確保できているか |

### ゲート承認プロセス

1. 📋 成果物のレビュー
2. 🔍 品質メトリクスの確認
3. 🚨 リスク・課題の評価
4. ✅ ステークホルダーの承認

❌ **Go/No-Go判断** - 基準を満たさない場合は次フェーズに進まない

## ITプロジェクト特有のライフサイクルモデル

### 1. ウォーターフォール型
- ➡️ 各フェーズを順次進行
- 📋 要件が明確な場合に適用
- 🏢 大規模システム、規制対応に有効

### 2. アジャイル型
- 🔄 短期間の反復開発
- 📱 Web/モバイルアプリに適用
- 🚀 早期リリースと継続的改善

### 3. ハイブリッド型
- 🔀 要件定義はウォーターフォール、開発はアジャイル
- ⚖️ 柔軟性と統制のバランス
- 🏗️ 基盤とアプリで手法を使い分け

## 成功要因と失敗要因

### 成功要因（Critical Success Factors）

1. **明確な要件定義** - 曖昧さを排除
2. **適切な技術選定** - 実績ある技術の採用
3. **優秀なチーム** - スキルとモチベーション
4. **継続的なコミュニケーション** - ステークホルダーとの対話
5. **段階的なリリース** - リスク分散

### 失敗要因（典型的なパターン）

- ❌ **要件の頻繁な変更** - スコープクリープ
- ❌ **技術的リスクの過小評価** - 実現可能性の検証不足
- ❌ **コミュニケーション不足** - 認識齟齬の蓄積
- ❌ **テスト期間の圧縮** - 品質問題の多発
- ❌ **スキル不足** - 見積もりと実績の乖離

💡 **ITプロジェクトは、技術的複雑性と変化の速さに対応するため、柔軟性と統制のバランスが重要です。ライフサイクル全体を見据えた計画と、継続的なリスク管理が成功の鍵となります。**',
    1,
    NOW()
  ) RETURNING id INTO v_lesson_id;

  -- Lesson 1: Questions (ひっかけ問題スタイル)
  INSERT INTO questions (lesson_id, type, question, options, correct_answer, explanation, "order", created_at)
  VALUES
    (v_lesson_id, 'multiple-answer', 'ITプロジェクトの「無形性」が引き起こす典型的な課題として適切なものを全て選択してください。',
     ARRAY['ステークホルダー間での要件の解釈にずれが生じやすい', 'プロトタイプやモックアップを早期に作成することで完全に解決できる', '進捗の可視化が困難で、実際の完成度が把握しづらい', 'プロジェクトの初期段階での品質評価が難しい'],
     ARRAY['ステークホルダー間での要件の解釈にずれが生じやすい', '進捗の可視化が困難で、実際の完成度が把握しづらい', 'プロジェクトの初期段階での品質評価が難しい'],
     'Bは一見正しそうですが、プロトタイプやモックアップは無形性の課題を「軽減」できても「完全に解決」することはできません。UIだけでなく内部ロジック、パフォーマンス、セキュリティなど見えない部分の品質や完成度は依然として把握が困難です。A、C、Dは無形性に起因する本質的な課題です。',
     1, NOW()),
    (v_lesson_id, 'multiple-choice', '要件定義フェーズでステークホルダーから「使いやすいシステム」という要求があった場合、PMとして最も適切な対応はどれですか？',
     ARRAY['ユーザビリティの専門家をアサインし、UI/UXデザインに注力する計画を立てる', '「使いやすさ」の定義と測定基準を具体化し、ステークホルダーと合意形成する', '過去の類似プロジェクトのUI設計を参考に、ベストプラクティスを適用する', 'アジャイル開発を採用し、スプリントレビューで継続的にフィードバックを得る'],
     ARRAY['「使いやすさ」の定義と測定基準を具体化し、ステークホルダーと合意形成する'],
     'A、C、Dはいずれも「使いやすさ」を実現する手段として有効ですが、最も重要なのは曖昧な要求を具体化することです。「使いやすさ」は人によって解釈が異なるため、まず測定可能な基準（例：特定タスクの完了時間、エラー発生率、学習時間など）を定義し、ステークホルダーと合意する必要があります。手段の検討はその後です。',
     2, NOW()),
    (v_lesson_id, 'multiple-answer', 'ウォーターフォール型開発でフェーズゲート管理を行う際、次フェーズへの移行判断基準として設定すべき要素を全て選択してください。',
     ARRAY['前フェーズの成果物が全て完成し、レビュー承認を得ている', '次フェーズの詳細計画とリソース配置が確定している', 'ステークホルダー全員が次フェーズ移行に賛成している', '前フェーズで発見された課題の影響度評価が完了している'],
     ARRAY['前フェーズの成果物が全て完成し、レビュー承認を得ている', '次フェーズの詳細計画とリソース配置が確定している', '前フェーズで発見された課題の影響度評価が完了している'],
     'Cは一見重要に思えますが、「全員の賛成」は現実的ではなく、適切なゲート管理では「関係者の合意」が求められますが「全員一致」は不要です。反対意見があっても、リスク評価と意思決定プロセスを経て進行判断することが実務的です。A、B、Dは定量的・客観的な判断基準として必須です。',
     3, NOW()),
    (v_lesson_id, 'multiple-choice', 'アジャイル開発を採用したITプロジェクトで、スプリント途中にステークホルダーから「優先度の高い新機能を今すぐ追加したい」という要求があった場合、スクラムマスターとして最も適切な対応はどれですか？',
     ARRAY['スプリントのゴールとコミットメントを優先し、次スプリントのバックログに追加する', 'ステークホルダーの要求は最優先なので、現在のスプリント計画を変更して対応する', 'プロダクトオーナーと協議し、現スプリントのスコープを調整できるか検討する', '緊急性を確認した上で、同価値のストーリーと入れ替えられるか開発チームと相談する'],
     ARRAY['スプリントのゴールとコミットメントを優先し、次スプリントのバックログに追加する'],
     'B、C、Dはいずれも一定の合理性がありますが、スクラムの原則では「スプリント中のスコープ変更は原則として行わない」ことが重要です。これはチームの集中力とベロシティの予測可能性を守るためです。真に緊急であればスプリント自体を中断（アボート）する選択肢もありますが、通常は次スプリントで対応するのが正しいアプローチです。C、Dは妥協案として現実的ですが、ベストプラクティスではありません。',
     4, NOW()),
    (v_lesson_id, 'multiple-choice', 'ITプロジェクトで「スコープクリープ」が発生する根本原因として最も本質的なものはどれですか？',
     ARRAY['ステークホルダーの要求が頻繁に変化するため', '変更管理プロセスが整備されていないため', '初期の要件定義が不十分で曖昧性が残っているため', 'プロジェクトマネージャーがステークホルダーの要求を断れないため'],
     ARRAY['初期の要件定義が不十分で曖昧性が残っているため'],
     'A、B、Dはいずれもスコープクリープの「要因」ですが、最も根本的な原因は「初期要件の曖昧性」です。要件が明確であれば、変更要求が来ても「スコープ内/外」の判断が可能になり、Bの変更管理プロセスも機能します。Aの要求変化やDのマネジメント課題も、明確な要件ベースラインがあれば管理可能です。スコープクリープの本質は「何がスコープなのかが不明確」であることです。',
     5, NOW());

  -- Lesson 2: アジャイル開発とスクラム実践
  INSERT INTO lessons (course_id, slug, title, content, "order", created_at)
  VALUES (
    v_course_id,
    'agile-scrum-practice',
    'アジャイル開発とスクラム実践',
    $CONTENT$# アジャイル開発とスクラム実践

アジャイル開発は、**変化に柔軟に対応し、継続的に価値を提供する反復的開発手法**です。

## アジャイルの基本原則

### アジャイルマニフェストの4つの価値

| 従来の価値 | アジャイルの価値 |
|----------|----------------|
| 📄 プロセスやツール | 👥 **個人と対話** |
| 📚 包括的なドキュメント | 💻 **動くソフトウェア** |
| 📝 契約交渉 | 🤝 **顧客との協調** |
| 📋 計画に従うこと | 🔄 **変化への対応** |

### アジャイルの12の原則（主要なもの）

1. **価値ある成果物の早期継続的な提供**
2. **変更要求を歓迎する** - 競争力の源泉
3. **短い時間間隔での提供** - 2週間〜2ヶ月
4. **ビジネス側と開発者の毎日の協働**
5. **動機づけられた個人を中心に構築**
6. **対面での対話が最も効果的**
7. **動くソフトウェアが進捗の第一の尺度**
8. **持続可能な開発ペース**

## スクラムフレームワーク

スクラムは、**アジャイル開発の代表的なフレームワーク**で、明確な役割・イベント・成果物が定義されています。

### スクラムの3つのロール

#### 1. プロダクトオーナー（PO）

**責任：**
- 📋 プロダクトバックログの管理
- 🎯 プロダクトの価値最大化
- ✅ 開発の優先順位決定
- 🔍 ステークホルダーとの調整

**重要：** POは意思決定権を持つ「1人」であるべき

#### 2. スクラムマスター（SM）

**責任：**
- 🛡️ スクラムプロセスの守護
- 🚧 障害の除去（インピーダンスの解消）
- 🎓 チームのコーチング
- 🔄 継続的改善の促進

**誤解：** プロジェクトマネージャーではない - サーバントリーダー

#### 3. 開発チーム

**特徴：**
- 👥 3〜9名の自己組織化されたチーム
- 🔀 クロスファンクショナル（多機能）
- 🎯 スプリントゴールへコミット
- 📊 タスクの見積もりと実行

### スクラムイベント

#### スプリント（本体）

- ⏱️ **期間：** 1〜4週間（通常2週間）
- 🎯 **目的：** 潜在的にリリース可能なインクリメントを作成
- 🔒 **ルール：** スプリント中はゴールを変更しない

#### スプリントプランニング

- ⏱️ **時間：** スプリント期間の5%程度（2週間なら4時間）
- 📋 **内容：**
  - What: 今スプリントで何を実現するか
  - How: どうやって実現するか
- 📊 **成果物：** スプリントバックログ

#### デイリースクラム（朝会）

- ⏱️ **時間：** 毎日15分
- 🎯 **目的：** 24時間の進捗同期と計画調整
- 📝 **3つの質問：**
  1. 昨日何をしたか
  2. 今日何をするか
  3. 障害は何か

**重要：** 詳細な技術議論の場ではない

#### スプリントレビュー

- ⏱️ **時間：** スプリント期間の2.5%程度（2週間なら2時間）
- 🎯 **目的：** 完成したインクリメントのデモとフィードバック収集
- 👥 **参加者：** ステークホルダーも参加
- 📋 **成果：** 次のバックログの調整

#### スプリントレトロスペクティブ（振り返り）

- ⏱️ **時間：** スプリント期間の1.5%程度（2週間なら1.5時間）
- 🎯 **目的：** プロセス改善の議論
- 📝 **観点：**
  - 何がうまくいったか
  - 何が問題だったか
  - 次に何を改善するか
- ✅ **成果物：** 改善アクションアイテム

### スクラムの成果物

#### 1. プロダクトバックログ

- 📋 プロダクトに必要な全ての機能・改善のリスト
- 🔝 優先順位付き（POが管理）
- 📊 ユーザーストーリー形式で記述
- 🔄 継続的に更新（グルーミング）

**ユーザーストーリーの形式：**
```
As a [ユーザー種別]
I want [機能]
So that [価値・理由]
```

#### 2. スプリントバックログ

- 📋 今スプリントで実装するバックログアイテム
- 📊 タスクに分解され、見積もり済み
- 🔄 デイリースクラムで更新
- 📈 バーンダウンチャートで可視化

#### 3. インクリメント

- ✅ 完成の定義（DoD: Definition of Done）を満たした成果物
- 🚀 潜在的にリリース可能
- 🔗 過去のインクリメントに追加される

## ベロシティとキャパシティプランニング

### ベロシティ

- 📊 チームが1スプリントで完了できるストーリーポイントの量
- 📈 過去3〜5スプリントの平均で算出
- 🎯 次スプリントの計画の基準

**注意：** ベロシティはチーム間で比較してはいけない

### ストーリーポイント見積もり

**相対見積もりの手法：**

| 手法 | 説明 |
|-----|------|
| 🎴 **プランニングポーカー** | フィボナッチ数列のカードで見積もり |
| 👕 **Tシャツサイズ** | XS/S/M/L/XLで相対的に見積もり |
| 🐕 **ドッグサイズ** | 犬の大きさで例えて見積もり |

**ストーリーポイントの基準：**
- 複雑性
- 作業量
- 不確実性

## スクラムのスケーリング

### 大規模スクラム（LeSS, SAFe）

複数チームでスクラムを実践する場合のフレームワーク：

#### LeSS（Large-Scale Scrum）

- 📋 1つのプロダクトバックログ
- 👥 複数の開発チーム（3〜8チーム）
- 👤 1人のプロダクトオーナー
- 🔄 同期されたスプリント

#### SAFe（Scaled Agile Framework）

- 🏢 エンタープライズ向け
- 📊 ポートフォリオ・プログラム・チームの3階層
- 🔄 PI（Program Increment）プランニング
- 📈 組織全体のアジャイル化

## アジャイルでの品質管理

### テスト駆動開発（TDD）

1. ❌ **Red:** 失敗するテストを書く
2. ✅ **Green:** テストが通る最小限のコードを書く
3. 🔄 **Refactor:** コードを改善

### 継続的インテグレーション（CI）

- 🔄 コードを頻繁に統合（1日複数回）
- ✅ 自動テストで品質担保
- 🚨 問題の早期発見

### 完成の定義（DoD）

**最低基準の例：**
- ✅ コードレビュー完了
- ✅ 単体テスト合格
- ✅ 統合テスト合格
- ✅ ドキュメント更新
- ✅ 受入基準を満たす

## スクラム導入の典型的な課題

### 組織的課題

| 課題 | 対策 |
|-----|------|
| 🏢 **上層部の理解不足** | エグゼクティブ向けトレーニング |
| 📊 **従来型の管理指標** | アジャイルメトリクスへの移行 |
| 👥 **固定的な組織構造** | クロスファンクショナルチーム編成 |
| 📋 **過度なドキュメント要求** | Working Agreementでバランス調整 |

### チーム内課題

- ❌ **POが不在・多忙** → デリゲーションと権限移譲
- ❌ **SMがPMの役割を兼務** → 役割の明確化
- ❌ **デイリースクラムが報告会に** → 自己組織化の促進
- ❌ **レトロが形骸化** → ファシリテーション手法の導入

💡 **スクラムは規律あるフレームワークです。全てのイベント・ロール・成果物に意味があり、省略や曖昧化は効果を損ないます。まずは正しいスクラムを実践し、その上でチームに合わせた調整を行うことが成功の鍵です。**$CONTENT$,
    2,
    NOW()
  ) RETURNING id INTO v_lesson_id;

  -- Lesson 2: Questions (ひっかけ問題スタイル)
  INSERT INTO questions (lesson_id, type, question, options, correct_answer, explanation, "order", created_at)
  VALUES
    (v_lesson_id, 'multiple-choice', 'スクラムでプロダクトオーナー（PO）が持つべき最も重要な権限はどれですか？',
     ARRAY['開発チームのメンバー選定と評価', 'スプリント中のタスク割り当てと進捗管理', 'プロダクトバックログの優先順位決定', 'スクラムイベントの開催日時の決定'],
     ARRAY['プロダクトバックログの優先順位決定'],
     'A、B、Dは一見POの権限のように思えますが、Aは組織マネージャー、Bは開発チームの自己組織化の範囲、Dはスクラムマスターとチームの調整事項です。POの最も重要な権限は「何を作るか」の優先順位決定であり、これがプロダクトの価値を最大化します。「どう作るか」は開発チームの領域です。',
     1, NOW()),
    (v_lesson_id, 'multiple-answer', 'デイリースクラムで扱うべき内容として適切なものを全て選択してください。',
     ARRAY['昨日完了したタスクと今日実施するタスクの共有', 'スプリントゴール達成に向けた障害の特定', 'コードの詳細な技術的問題の議論と解決策の検討', '次スプリントで実装する機能の優先順位議論'],
     ARRAY['昨日完了したタスクと今日実施するタスクの共有', 'スプリントゴール達成に向けた障害の特定'],
     'デイリースクラムは15分の同期会議であり、AとBが目的です。Cの詳細な技術議論はデイリースクラム後に別途実施すべきで、Dは次スプリントの話題なのでスプリントプランニングやバックログリファインメントで扱います。デイリースクラムを長時間化・拡大解釈することはスクラムの規律を損ないます。',
     2, NOW()),
    (v_lesson_id, 'multiple-choice', 'スプリント期間中にステークホルダーから「重要な新機能を今すぐ追加したい」と要求された場合、プロダクトオーナーが取るべき最も適切な対応はどれですか？',
     ARRAY['ステークホルダーの要求なので、開発チームに今すぐ追加実装を指示する', '次スプリントのバックログに追加し、優先順位を上げて次回実装する', 'スプリントゴールを変更し、現在の作業と新機能のバランスを調整する', '緊急性を評価し、真に緊急であれば現スプリントを中断（アボート）して新スプリントを開始する'],
     ARRAY['緊急性を評価し、真に緊急であれば現スプリントを中断（アボート）して新スプリントを開始する'],
     'A、B、Cはいずれも一定の合理性がありますが、スクラムの原則では「スプリント中のゴール変更は行わない」ことが重要です。Bは通常の対応、Cはゴール変更なので不適切。Aは開発チームの自己組織化を侵害します。真に緊急でビジネス環境が変化した場合のみ、POはスプリントをアボート（中断）する権限を持ちます。これは例外的措置ですが、最も原則に忠実な対応です。',
     3, NOW()),
    (v_lesson_id, 'multiple-answer', 'スプリントレトロスペクティブで議論すべき内容として適切なものを全て選択してください。',
     ARRAY['今スプリントでうまくいったプラクティスの特定', 'チーム内のコミュニケーション方法の改善案', '完成しなかった機能の技術的原因の詳細分析', '次スプリントで実装する具体的な機能の計画'],
     ARRAY['今スプリントでうまくいったプラクティスの特定', 'チーム内のコミュニケーション方法の改善案'],
     'レトロスペクティブは「プロセス改善」の場であり、AとBが目的です。Cの技術的原因分析は有用ですが、詳細すぎる議論は本来の目的から逸脱します（プロセスの観点で「なぜ完成しなかったか」を議論するのは適切）。Dは完全にスプリントプランニングの内容です。レトロは「どう働くか」を改善する場であり、「何を作るか」を議論する場ではありません。',
     4, NOW()),
    (v_lesson_id, 'multiple-choice', 'ベロシティを用いた計画で最も重要な原則はどれですか？',
     ARRAY['ベロシティを高めることをチームの目標にする', 'ベロシティを他チームと比較してチームの生産性を評価する', 'ベロシティはチームのキャパシティ予測に使い、過去の平均値を基に現実的な計画を立てる', 'ベロシティが低いチームのメンバーを入れ替えて改善する'],
     ARRAY['ベロシティはチームのキャパシティ予測に使い、過去の平均値を基に現実的な計画を立てる'],
     'A、B、Dはベロシティの誤用です。ベロシティは「予測ツール」であり「評価指標」ではありません。Aのようにベロシティ向上を目標にすると見積もりのインフレが起き、Bのようにチーム間比較すると各チームのストーリーポイント基準が異なるため無意味です。Dはベロシティの本質的誤解です。Cが正しい使い方で、チームが持続可能なペースで計画するための予測値として使います。',
     5, NOW());

  -- Lesson 3: ウォーターフォール開発とV字モデル運用
  INSERT INTO lessons (course_id, slug, title, content, "order", created_at)
  VALUES (
    v_course_id,
    'waterfall-v-model',
    'ウォーターフォール開発とV字モデル運用',
    $CONTENT$# ウォーターフォール開発とV字モデル運用

ウォーターフォール開発は、**各フェーズを順次進行し、上流工程での品質確保を重視する計画駆動型開発手法**です。

## ウォーターフォールモデルの基本

### 標準的なフェーズ構成

```
要件定義 → 基本設計 → 詳細設計 → 実装 → テスト → リリース → 保守
```

### 各フェーズの特徴

#### 1. 要件定義フェーズ

**成果物：**
- 📋 要件定義書（機能要件・非機能要件）
- 📊 業務フロー図
- 🎯 システム化範囲定義

**レビュー観点：**
- ✅ ステークホルダーの合意取得
- ✅ 曖昧性の排除
- ✅ 実現可能性の確認

#### 2. 基本設計（外部設計）

**成果物：**
- 🏗️ システム構成図
- 🖼️ 画面設計書
- 🔗 インターフェース設計書
- 🗄️ データベース概念設計

**重要性：** ユーザー視点での機能定義

#### 3. 詳細設計（内部設計）

**成果物：**
- 📐 モジュール設計書
- 🔀 処理フロー図
- 🗄️ データベース物理設計
- 📊 性能設計書

**重要性：** 実装の設計図となる精密な仕様

#### 4. 実装（コーディング）

**活動：**
- 💻 コーディング
- 🔍 コードレビュー
- ✅ 単体テスト
- 📚 ドキュメント整備

#### 5. テストフェーズ

段階的なテスト実施：

| テストレベル | 目的 | 対応する設計フェーズ |
|------------|------|-------------------|
| 🔧 **単体テスト** | モジュール単位の動作確認 | 詳細設計 |
| 🔗 **結合テスト** | モジュール間連携確認 | 基本設計 |
| 🖥️ **システムテスト** | システム全体の機能・性能確認 | 要件定義 |
| 👤 **受入テスト** | ビジネス要件の充足確認 | 要件定義 |

## V字モデル（検証と妥当性確認）

V字モデルは、**上流工程と下流のテストを対応させ、品質を体系的に担保する**モデルです。

### V字の左側（開発）と右側（検証）

```
        要件定義 ←→ 受入テスト
           ↓           ↑
        基本設計 ←→ システムテスト
           ↓           ↑
        詳細設計 ←→ 結合テスト
           ↓           ↑
          実装  ←→ 単体テスト
```

### V字モデルの重要原則

#### 1. トレーサビリティ

各要件がどの設計・実装・テストケースに対応するかを追跡可能にする。

**トレーサビリティマトリクス：**

| 要件ID | 基本設計ID | 詳細設計ID | テストケースID |
|-------|-----------|-----------|--------------|
| REQ-001 | BD-010 | DD-045 | TC-123 |
| REQ-002 | BD-011 | DD-046, DD-047 | TC-124, TC-125 |

**効果：**
- 🔍 漏れの防止
- 📊 影響範囲の特定
- ✅ カバレッジの可視化

#### 2. 早期テスト設計

**原則：** 設計と同時にテストケースを作成

| フェーズ | 同時に設計するテスト |
|---------|-------------------|
| 要件定義 | 受入テストシナリオ |
| 基本設計 | システムテストケース |
| 詳細設計 | 結合テストケース |
| 実装 | 単体テストケース |

**メリット：**
- 🎯 設計の曖昧性を早期発見
- ✅ テスト漏れの防止
- 📈 テスト期間の短縮

#### 3. レビューによる品質作り込み

**静的検証（テスト前の検証）：**
- 📄 ドキュメントレビュー
- 🔍 コードインスペクション
- 🎯 ウォークスルー

**効果：** 下流での手戻りを大幅削減（バグ修正コストは下流ほど高い）

## フェーズゲート管理

### ゲートの役割

各フェーズ完了時に、**品質とリスクを評価し、次フェーズへの進行可否を判断**します。

### ゲート判断基準

#### 1. 成果物の完成度

- ✅ 必須成果物が全て揃っている
- ✅ 成果物が承認基準を満たしている
- ✅ レビュー指摘事項がクローズしている

#### 2. 品質メトリクス

**要件定義ゲート：**
- 要件の曖昧度指数 < 5%
- ステークホルダー合意率 = 100%

**設計ゲート：**
- レビュー指摘密度 < 1件/ページ
- 設計書の完成度 = 100%

**実装ゲート：**
- 単体テストカバレッジ > 80%
- コードレビュー指摘対応率 = 100%

**テストゲート：**
- テストケース消化率 = 100%
- 未解決バグ（重要度高） = 0件

#### 3. リスク評価

- 🚨 次フェーズへの影響リスク評価
- 📊 残課題の影響度分析
- 🔄 リスク対応計画の妥当性

### Go/No-Go判断

| 判断 | 基準 | 対応 |
|------|------|------|
| ✅ **Go** | 全基準を満たす | 次フェーズへ進行 |
| ⚠️ **条件付きGo** | 軽微な課題あり | 条件付きで進行（課題管理） |
| ❌ **No-Go** | 重大な課題あり | フェーズ継続・手戻り |

## ウォーターフォールの利点と課題

### 利点

| 利点 | 説明 |
|------|------|
| 📋 **計画性** | 全体スケジュール・コストが見通しやすい |
| 📚 **文書化** | 体系的なドキュメントが残る |
| 🎯 **役割明確** | フェーズごとに役割が明確 |
| 🏢 **契約親和性** | 固定価格契約に適合しやすい |
| 🔍 **監査対応** | トレーサビリティが高く監査に強い |

### 課題と対策

#### 課題1: 変更への柔軟性不足

**対策：**
- 📋 変更管理プロセスの整備
- 🔄 影響度分析の迅速化
- 💰 変更予算の確保

#### 課題2: 後戻りコストの高さ

**対策：**
- 🔍 上流工程でのレビュー強化
- 👥 ステークホルダーの継続的関与
- 🎯 プロトタイプでの早期検証

#### 課題3: テスト後半での問題集中

**対策：**
- ✅ 早期テスト設計
- 🔄 継続的インテグレーション
- 📊 品質メトリクスの監視

#### 課題4: ユーザーフィードバックの遅延

**対策：**
- 🎨 モックアップでの事前確認
- 🔄 フェーズごとのステークホルダーレビュー
- 🚀 段階的リリース（可能であれば）

## ウォーターフォールとアジャイルのハイブリッド

### ハイブリッドアプローチの設計

**組み合わせパターン：**

#### パターン1: フェーズ別使い分け

- 要件定義・基本設計：ウォーターフォール（全体の枠組み確定）
- 詳細設計〜実装：アジャイル（機能ごとの反復開発）

#### パターン2: システム領域別使い分け

- 基盤システム：ウォーターフォール（安定性重視）
- アプリケーション：アジャイル（変化対応重視）

#### パターン3: 時間軸での使い分け

- 初期リリース：ウォーターフォール（最小機能セット）
- 継続改善：アジャイル（機能追加・改善）

### ハイブリッドの成功要因

1. **明確な境界定義** - どこでどの手法を使うか明確化
2. **インターフェース管理** - 両手法の接点を明確化
3. **柔軟なマインドセット** - 適材適所の判断

💡 **ウォーターフォールは「計画重視」、V字モデルは「品質重視」のアプローチです。上流での品質作り込みと体系的な検証により、大規模・高信頼性が求められるシステムで効果を発揮します。変化への対応が課題ですが、適切な変更管理とハイブリッドアプローチで克服可能です。**$CONTENT$,
    3,
    NOW()
  ) RETURNING id INTO v_lesson_id;

  -- Lesson 3: Questions
  INSERT INTO questions (lesson_id, type, question, options, correct_answer, explanation, "order", created_at)
  VALUES
    (v_lesson_id, 'multiple-choice', 'V字モデルで「要件定義フェーズ」と対応するテストフェーズはどれですか？',
     ARRAY['単体テスト', '結合テスト', 'システムテスト', '受入テスト'],
     ARRAY['受入テスト'],
     '一見「システムテスト」も正解に思えますが、V字モデルでは要件定義はビジネス要件を定義するフェーズであり、それを検証するのは「ビジネス要件が満たされているか」を確認する受入テストです。システムテストは基本設計（システムとしての機能仕様）と対応します。この対応関係の理解が重要です。',
     1, NOW()),
    (v_lesson_id, 'multiple-answer', 'フェーズゲートで「条件付きGo」判断を下す場合の適切な条件を全て選択してください。',
     ARRAY['軽微なドキュメント誤記が数件残っているが、次フェーズに影響しない', '重要な非機能要件の性能目標値が未確定だが、後で決める予定', '単体テストカバレッジが75%だが、残りは次フェーズで対応予定', 'レビュー指摘の対応計画が明確で、期限内に解決可能'],
     ARRAY['軽微なドキュメント誤記が数件残っているが、次フェーズに影響しない', 'レビュー指摘の対応計画が明確で、期限内に解決可能'],
     'AとDは軽微で管理可能な課題のため条件付きGoが妥当です。しかしBの性能目標値未確定は設計に重大な影響を与え、Cのカバレッジ不足は品質リスクが高く、いずれも「次フェーズに進んでから対応」では手戻りが大きくなります。条件付きGoは「軽微で管理可能な課題」に限定すべきです。',
     2, NOW()),
    (v_lesson_id, 'multiple-choice', 'トレーサビリティマトリクスを作成する最も重要な目的はどれですか？',
     ARRAY['プロジェクトの進捗を可視化し、ステークホルダーに報告する', '要件・設計・実装・テストの対応関係を明確にし、漏れや影響範囲を管理する', 'チームメンバーの作業量を測定し、パフォーマンス評価に使用する', 'ドキュメントの目次として使用し、成果物の整理に役立てる'],
     ARRAY['要件・設計・実装・テストの対応関係を明確にし、漏れや影響範囲を管理する'],
     'A、C、Dはトレーサビリティマトリクスの副次的効果や誤用です。最も重要な目的はBの「対応関係の明確化」です。これにより、①要件の実装漏れ防止、②変更時の影響範囲特定、③テストカバレッジ確認が可能になります。進捗管理やパフォーマンス評価はトレーサビリティの本来の目的ではありません。',
     3, NOW()),
    (v_lesson_id, 'multiple-answer', 'ウォーターフォール開発で「上流工程での品質作り込み」を実現する手法として適切なものを全て選択してください。',
     ARRAY['設計フェーズと同時にテストケースを設計する', '要件定義書のレビューを複数回実施し、曖昧性を排除する', 'コーディング後に詳細なテストを実施してバグを検出する', 'プロトタイプを作成してステークホルダーと認識を合わせる'],
     ARRAY['設計フェーズと同時にテストケースを設計する', '要件定義書のレビューを複数回実施し、曖昧性を排除する', 'プロトタイプを作成してステークホルダーと認識を合わせる'],
     'Cは「下流での品質検証」であり、上流での作り込みではありません。ウォーターフォールの原則は「バグを作らない」ことであり、「バグを見つける」ことではありません。A、B、Dは上流でのレビュー・検証・合意形成により、下流での手戻りを防ぐ手法です。バグ修正コストは下流ほど高いため、上流での作り込みが重要です。',
     4, NOW()),
    (v_lesson_id, 'multiple-choice', 'ウォーターフォールとアジャイルのハイブリッドアプローチで最も重要な成功要因はどれですか？',
     ARRAY['すべてのチームメンバーが両方の手法を深く理解している', 'どのフェーズ・領域でどちらの手法を使うか明確に定義されている', 'プロジェクトの途中で自由に手法を切り替えられる柔軟性がある', 'ウォーターフォールとアジャイルの比率が50%ずつで均等である'],
     ARRAY['どのフェーズ・領域でどちらの手法を使うか明確に定義されている'],
     'A、C、Dは一見合理的ですが、ハイブリッドの本質ではありません。Aは理想ですが必須ではなく、Cの「自由な切り替え」は混乱を招き、Dの「均等な比率」に意味はありません。最も重要なのはBの「境界の明確化」です。どこで何を使うかが不明確だと、チームは混乱し、両手法の利点が失われます。ハイブリッドは「適材適所」であり、その境界定義が成功の鍵です。',
     5, NOW());

  -- Lesson 4: 要件定義とステークホルダー管理
  INSERT INTO lessons (course_id, slug, title, content, "order", created_at)
  VALUES (
    v_course_id,
    'requirements-stakeholder-management',
    '要件定義とステークホルダー管理',
    $CONTENT$# 要件定義とステークホルダー管理

要件定義は、**ステークホルダーのニーズを具体的で検証可能な要件に変換し、プロジェクトの成功基準を明確にする**プロセスです。

## 要件の分類

### 機能要件と非機能要件

| 分類 | 内容 | 例 |
|-----|------|---|
| **機能要件** | システムが「何をするか」 | ユーザー登録、検索、決済処理 |
| **非機能要件** | システムが「どうあるべきか」 | 性能、可用性、セキュリティ |

### 非機能要件の詳細分類

#### 1. 性能要件

- ⚡ **応答時間：** 画面表示3秒以内
- 📊 **スループット：** 同時接続1000ユーザー
- 💾 **リソース使用量：** CPU使用率70%以下

#### 2. 可用性要件

- 🔄 **稼働率：** 99.9%以上（ダウンタイム月43分以内）
- 🛡️ **障害復旧時間：** RTO（Recovery Time Objective）4時間
- 💾 **データ損失許容：** RPO（Recovery Point Objective）1時間

#### 3. セキュリティ要件

- 🔐 **認証・認可：** 多要素認証、ロールベースアクセス制御
- 🔒 **暗号化：** 通信はTLS1.3、保存データはAES256
- 📝 **監査ログ：** 全操作のログ記録と3年間保存

#### 4. 保守性要件

- 🔧 **変更容易性：** モジュール化設計
- 📚 **ドキュメント：** API仕様書、運用手順書
- 🧪 **テスタビリティ：** 単体テストカバレッジ80%以上

#### 5. 互換性要件

- 🌐 **ブラウザ対応：** Chrome最新版、Firefox最新版、Safari最新版
- 📱 **デバイス対応：** iOS16以上、Android12以上
- 🔗 **外部システム連携：** REST API、SOAP

## 要件の品質特性

### 良い要件の条件（SMART基準）

| 基準 | 説明 | 悪い例 | 良い例 |
|------|------|--------|--------|
| **Specific（具体的）** | 曖昧でない | 「高速に動作する」 | 「検索結果を3秒以内に表示」 |
| **Measurable（測定可能）** | 検証できる | 「使いやすい」 | 「5回のクリックで注文完了」 |
| **Achievable（達成可能）** | 実現可能 | 「ダウンタイムゼロ」 | 「可用性99.9%」 |
| **Relevant（関連性）** | ビジネス価値がある | 「アニメーション追加」 | 「CV率5%向上のためのUI改善」 |
| **Time-bound（期限明確）** | いつまでに実現 | 「将来的に対応」 | 「第2フェーズで実装」 |

### 要件の優先順位付け

#### MoSCoW法

| 優先度 | 意味 | 判断基準 |
|-------|------|----------|
| 🔴 **Must（必須）** | これがないとリリース不可 | ビジネス要件の中核 |
| 🟠 **Should（重要）** | 非常に重要だが代替案あり | 価値は高いが回避可能 |
| 🟡 **Could（希望）** | あれば嬉しい | リソースに余裕があれば |
| ⚪ **Won't（対象外）** | 今回はスコープ外 | 将来バージョンで検討 |

#### Kano モデル

要件を顧客満足度の観点で分類：

- 🎯 **当たり前品質：** ないと不満（例：基本的なセキュリティ）
- 📈 **一元的品質：** あるほど満足（例：処理速度）
- ✨ **魅力的品質：** あると驚き（例：AI推薦機能）

## ステークホルダー管理

### ステークホルダーの特定と分析

#### パワー・関心マトリクス

```
       高関心
         ↑
    C   |   A
 低───────┼───────高  パワー
パワー  D   |   B
         ↓
       低関心
```

| 象限 | 特徴 | 対応戦略 |
|------|------|----------|
| **A: 主要ステークホルダー** | 高パワー・高関心 | 密接な協働、定期報告 |
| **B: 満足維持** | 高パワー・低関心 | 情報提供、関心を維持 |
| **C: 情報提供** | 低パワー・高関心 | 適度な情報共有 |
| **D: 最小限の監視** | 低パワー・低関心 | 一般的な情報提供のみ |

### ステークホルダーエンゲージメント

#### 1. 要件収集手法

**インタビュー：**
- 🎤 1対1またはグループインタビュー
- 📝 半構造化質問で深掘り
- ⚠️ バイアスに注意

**ワークショップ：**
- 👥 複数ステークホルダーで議論
- 🎯 合意形成を促進
- ⏱️ ファシリテーションが重要

**観察・シャドーイング：**
- 👀 実際の業務を観察
- 💡 言語化されていないニーズを発見
- 📸 ビデオ記録で分析

**プロトタイピング：**
- 🎨 モックアップで視覚化
- 🔄 早期フィードバック
- ✅ 認識齟齬の解消

**アンケート：**
- 📊 多数のステークホルダーから収集
- 📈 定量的データ取得
- ⚠️ 詳細情報は得にくい

#### 2. 要件の妥当性確認

**レビュー会議：**
- 📋 要件定義書のウォークスルー
- ✅ ステークホルダーの承認取得
- 📝 指摘事項の記録

**受入基準の明確化：**
- 🎯 各要件の検証方法を定義
- ✅ Given-When-Then形式
- 📊 測定可能な基準設定

#### 3. 要件の変更管理

**変更管理プロセス：**

1. 📝 **変更要求の受付** - フォーマット化
2. 🔍 **影響度分析** - スコープ・コスト・スケジュール・リスク
3. 💰 **優先順位評価** - ビジネス価値とコスト
4. ✅ **承認プロセス** - 変更管理委員会（CCB）
5. 🔄 **実装と追跡** - ベースラインの更新

**変更管理委員会（CCB）：**
- 👥 メンバー：PM、PO、主要ステークホルダー、技術リーダー
- 🎯 役割：変更の承認・却下判断
- 📊 判断基準：ROI、リスク、戦略整合性

## 要件の文書化

### 要件定義書の構成

#### 標準的な目次

1. **概要**
   - プロジェクト背景・目的
   - システム化の範囲
   - 用語定義

2. **機能要件**
   - ユースケース図
   - 機能一覧
   - 画面遷移図
   - 業務フロー

3. **非機能要件**
   - 性能要件
   - セキュリティ要件
   - 可用性要件
   - その他制約条件

4. **外部インターフェース**
   - 連携システム仕様
   - データフォーマット
   - 通信プロトコル

5. **受入基準**
   - 各要件の検証方法
   - テストシナリオ

### ユースケース記述

**テンプレート：**

```
ユースケース名: ユーザー登録
アクター: 新規ユーザー
事前条件: ユーザーは未登録
基本フロー:
  1. ユーザーが登録画面を開く
  2. システムが登録フォームを表示
  3. ユーザーがメールアドレスとパスワードを入力
  4. システムが入力値を検証
  5. システムがアカウントを作成
  6. システムが確認メールを送信
代替フロー:
  4a. 入力値が不正な場合、エラーメッセージを表示
  4b. メールアドレスが既に登録済みの場合、その旨を通知
事後条件: ユーザーアカウントが作成され、確認メールが送信される
```

### ユーザーストーリー（アジャイル）

**フォーマット：**

```
As a [ユーザー種別]
I want [機能]
So that [価値・理由]

受入基準:
- Given [前提条件]
- When [アクション]
- Then [期待結果]
```

**例：**

```
As a ECサイトの購入者
I want ショッピングカートに商品を追加できる
So that 複数商品をまとめて購入できる

受入基準:
- Given ユーザーが商品詳細ページにいる
- When 「カートに追加」ボタンをクリック
- Then 商品がカートに追加され、カートアイコンの数字が増える
```

## ステークホルダー管理の課題と対策

### 典型的な課題

| 課題 | 原因 | 対策 |
|------|------|------|
| **要件の曖昧性** | ステークホルダーが明確化できない | プロトタイプで具体化 |
| **要件の衝突** | 異なるステークホルダーの利害対立 | 優先順位付けワークショップ |
| **スコープクリープ** | 初期要件が不明確 | ベースライン設定と変更管理 |
| **コミュニケーション不足** | ステークホルダーが多忙 | 定期的な短時間ミーティング |
| **権限不明確** | 意思決定者が不在 | RACI図で責任明確化 |

### RACI図による責任明確化

| タスク | PM | PO | 開発 | QA | ステークホルダー |
|--------|----|----|------|----|-----------------|
| 要件定義 | A | R | C | I | C |
| 優先順位決定 | C | R/A | I | I | C |
| 変更承認 | A | R | C | I | C |
| 受入テスト | A | R | I | C | C |

- R: Responsible（実行責任）
- A: Accountable（説明責任）
- C: Consulted（相談先）
- I: Informed（報告先）

💡 **要件定義の品質がプロジェクト成功の80%を決めます。曖昧な要件は下流で指数関数的にコストを増大させるため、上流での徹底的な明確化と合意形成が不可欠です。ステークホルダーとの継続的なコミュニケーションと適切な変更管理により、変化にも柔軟に対応できます。**$CONTENT$,
    4,
    NOW()
  ) RETURNING id INTO v_lesson_id;

  -- Lesson 4: Questions
  INSERT INTO questions (lesson_id, type, question, options, correct_answer, explanation, "order", created_at)
  VALUES
    (v_lesson_id, 'multiple-choice', '「システムは使いやすくなければならない」という要件記述の最大の問題点はどれですか？',
     ARRAY['ビジネス価値が明確でないため、優先順位付けができない', '測定可能でないため、要件が満たされたか検証できない', '技術的実現可能性が評価できないため、見積もりができない', 'ステークホルダーの合意が取れていないため、承認できない'],
     ARRAY['測定可能でないため、要件が満たされたか検証できない'],
     'A、C、Dも問題になり得ますが、最大の問題はBです。「使いやすさ」は主観的で測定不可能なため、開発完了時に「要件を満たしているか」を客観的に判断できません。これは受入テストでの紛争原因になります。SMART基準では「測定可能（Measurable）」が必須であり、例えば「主要タスクを5クリック以内で完了できる」のように定量化すべきです。',
     1, NOW()),
    (v_lesson_id, 'multiple-answer', 'MoSCoW法で「Must（必須）」に分類すべき要件の特徴を全て選択してください。',
     ARRAY['これがないとシステムのビジネス価値が実現できない', '競合他社も実装している機能である', 'ステークホルダーが強く要望している', '法規制やコンプライアンスで必須とされている'],
     ARRAY['これがないとシステムのビジネス価値が実現できない', '法規制やコンプライアンスで必須とされている'],
     'Mustの判断基準は「これがないとリリースできない」ことです。AとDがこれに該当します。Bの競合の実装状況は参考情報ですがMustの判断基準ではなく、Cのステークホルダー要望も重要ですが「強く要望」だけではMustの根拠になりません。Mustは感情や要望ではなく、ビジネス要件の必須性や法的義務で判断すべきです。Should以下との境界を正しく引くことが重要です。',
     2, NOW()),
    (v_lesson_id, 'multiple-choice', 'パワー・関心マトリクスで「高パワー・低関心」のステークホルダーへの対応として最も適切なのはどれですか？',
     ARRAY['プロジェクトへの関心が低いため、最小限の情報提供に留める', '定期的に詳細な進捗報告を行い、密接に協働する', '関心を高めるため頻繁にコミュニケーションを取り、巻き込む', '満足を維持するため、要約された情報提供と重要事項の報告を行う'],
     ARRAY['満足を維持するため、要約された情報提供と重要事項の報告を行う'],
     'Aは「低パワー・低関心」の対応、Bは「高パワー・高関心」の対応です。Cは一見正しそうですが、低関心の相手に「頻繁な」コミュニケーションは負担となり逆効果です。Dが正解で、高パワーなので無視できないが低関心なので詳細は不要、という微妙なバランスを取ります。重要なのは「満足維持」であり、問題が起きない限り詳細に巻き込まないことです。',
     3, NOW()),
    (v_lesson_id, 'multiple-answer', '要件の変更管理プロセスで変更管理委員会（CCB）が承認判断する際に評価すべき要素を全て選択してください。',
     ARRAY['変更によるビジネス価値とROI', 'スコープ・コスト・スケジュールへの影響', '変更要求を出したステークホルダーの役職', '技術的実現可能性とリスク'],
     ARRAY['変更によるビジネス価値とROI', 'スコープ・コスト・スケジュールへの影響', '技術的実現可能性とリスク'],
     'CCBは変更の「価値とコスト」を客観的に評価します。A、B、Dは合理的な判断基準です。しかしCの「役職」は判断基準として不適切です。役職に関わらず、変更の価値・影響・実現可能性で判断すべきです。もちろん、役職者の戦略的判断は考慮されますが、それは「その人の役職」ではなく「その変更の戦略的価値」を評価しているのです。',
     4, NOW()),
    (v_lesson_id, 'multiple-choice', 'ユーザーストーリーの受入基準を「Given-When-Then」形式で記述する最も重要な目的はどれですか？',
     ARRAY['開発者がコーディングしやすいように実装手順を示す', '要件が満たされたかを客観的に検証できるテスト条件を明確にする', 'プロダクトオーナーが優先順位を判断しやすくする', 'ステークホルダーに要件の詳細を説明するためのドキュメントを提供する'],
     ARRAY['要件が満たされたかを客観的に検証できるテスト条件を明確にする'],
     'Given-When-Then形式は「受入基準」、つまり「この要件が完成したと言える条件」を明確にするための記法です。Bが正解です。Aは実装詳細であり要件定義の範囲外、Cは優先順位はストーリーポイントやビジネス価値で判断、Dは説明用ではなく検証用です。この形式により、開発前にPOと開発チームが「何ができれば完成か」の合意を形成し、完成後に客観的に検証できます。',
     5, NOW());

END $$;
