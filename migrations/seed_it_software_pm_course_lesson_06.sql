-- IT・ソフトウェア開発プロジェクトマネジメントコース
-- Lesson 6: 品質保証とテスト戦略

DO $$
DECLARE
  v_course_id INT;
  v_lesson_id INT;
BEGIN
  -- Get course ID
  SELECT id INTO v_course_id FROM courses WHERE slug = 'it-software-pm';

  -- Lesson 6: 品質保証とテスト戦略
  INSERT INTO lessons (course_id, slug, title, content, "order", created_at)
  VALUES (
    v_course_id,
    'qa-test-strategy',
    '品質保証とテスト戦略',
    $CONTENT$# 品質保証とテスト戦略

品質保証（QA）は、**プロセス全体を通じて品質を作り込み、テストによって検証する**体系的なアプローチです。

## 品質とは何か

### ソフトウェア品質の定義

| 観点 | 説明 | 評価方法 |
|------|------|----------|
| **機能適合性** | 要件を満たしているか | 機能テスト |
| **性能効率性** | 応答時間、スループット | 性能テスト |
| **互換性** | 他システムと共存できるか | 統合テスト |
| **使用性** | 使いやすいか | ユーザビリティテスト |
| **信頼性** | 障害なく動作するか | 信頼性テスト |
| **セキュリティ** | 脅威から保護されているか | セキュリティテスト |
| **保守性** | 変更しやすいか | コードレビュー、メトリクス |
| **移植性** | 他環境に移行できるか | 移植性テスト |

### 品質コストの分類

**予防コスト：** 品質問題を防ぐための投資
- 📋 要件レビュー、設計レビュー
- 🎓 トレーニング、プロセス改善

**評価コスト：** 品質を測定するための投資
- 🧪 テスト実施、コードレビュー
- 🔍 インスペクション

**内部失敗コスト：** リリース前の修正コスト
- 🐛 バグ修正、再テスト
- 🔄 手戻り作業

**外部失敗コスト：** リリース後の修正コスト
- 🚨 顧客クレーム対応
- 💰 補償、信用失墜

**原則：** 予防コストへの投資が、失敗コストを大幅に削減

## テストレベルとテスト種別

### テストレベル（実施段階）

#### 1. 単体テスト（ユニットテスト）

**対象：** 個別のモジュール・関数・クラス

**実施者：** 開発者

**目的：**
- ✅ ロジックの正確性
- ✅ エッジケースの処理
- ✅ エラーハンドリング

**手法：**
- 🧪 テストフレームワーク（JUnit、pytest、Jest）
- 🎭 モック・スタブの活用
- 📊 コードカバレッジ測定

**カバレッジ目標：**
- ⭐ 推奨：80%以上
- 🎯 重要ロジック：100%

#### 2. 統合テスト（結合テスト）

**対象：** モジュール間の連携

**実施者：** 開発者・QAエンジニア

**目的：**
- 🔗 インターフェースの整合性
- 📊 データの受け渡し
- 🔄 トランザクション処理

**アプローチ：**
- 📈 **ボトムアップ:** 下位モジュールから統合
- 📉 **トップダウン:** 上位モジュールから統合
- 🎯 **ビッグバン:** 全モジュールを一度に統合
- 🔄 **サンドイッチ:** 上記の組み合わせ

#### 3. システムテスト

**対象：** システム全体

**実施者：** QAエンジニア

**目的：**
- ✅ 機能要件の検証
- ✅ 非機能要件の検証
- ✅ エンドツーエンドのシナリオ

**含まれるテスト：**
- 🎯 機能テスト
- ⚡ 性能テスト
- 🔒 セキュリティテスト
- 🔄 可用性テスト

#### 4. 受入テスト（UAT）

**対象：** ビジネス要件の充足

**実施者：** エンドユーザー・ビジネス側

**目的：**
- ✅ ビジネス価値の実現
- ✅ 実運用環境での動作確認
- ✅ ユーザビリティの確認

**種類：**
- 👤 **アルファテスト:** 開発環境でのユーザーテスト
- 🌍 **ベータテスト:** 実環境での限定公開

### テスト種別（テストの目的）

#### 1. 機能テスト

**ブラックボックステスト：**
- 🎯 入力と期待される出力を検証
- 📋 仕様書ベースのテスト

**テスト技法：**

| 技法 | 説明 | 例 |
|------|------|---|
| **同値分割** | 入力を有効・無効なクラスに分割 | 年齢：0-17、18-64、65+ |
| **境界値分析** | 境界付近の値をテスト | 0、1、17、18、64、65 |
| **デシジョンテーブル** | 条件の組み合わせを網羅 | 会員種別×購入金額の割引 |
| **状態遷移テスト** | 状態の遷移を検証 | 注文ステータスの変化 |

**ホワイトボックステスト：**
- 🔍 コード構造に基づくテスト
- 📊 制御フロー、データフローの検証

#### 2. 非機能テスト

**性能テスト：**

| 種類 | 目的 | 手法 |
|------|------|------|
| **負荷テスト** | 想定負荷での性能確認 | 同時1000ユーザー |
| **ストレステスト** | 限界性能の確認 | 負荷を徐々に増加 |
| **スパイクテスト** | 急激な負荷変動への対応 | 瞬間的に負荷を増加 |
| **耐久テスト** | 長時間稼働での安定性 | 24時間連続稼働 |

**セキュリティテスト：**
- 🔐 脆弱性スキャン（OWASP ZAP、Burp Suite）
- 🎭 ペネトレーションテスト
- ✅ 認証・認可のテスト
- 🔒 暗号化の検証

**ユーザビリティテスト：**
- 👤 実ユーザーによる操作観察
- ⏱️ タスク完了時間の測定
- 📝 満足度アンケート

#### 3. 変更関連テスト

**リグレッションテスト（回帰テスト）：**
- 🔄 既存機能が壊れていないことを確認
- 🤖 自動化が必須
- 📊 CI/CDパイプラインに組み込み

**スモークテスト（サニティテスト）：**
- 🔥 基本的な機能の動作確認
- ⚡ 短時間（5-15分）で実施
- 🚨 ビルド直後に実施し、重大な問題を早期発見

## テスト戦略の策定

### テスト戦略ドキュメント

**含めるべき内容：**

1. **テストの目的とスコープ**
   - 何をテストするか
   - 何をテストしないか

2. **テストレベルと責任**
   - 各レベルの実施者
   - 合格基準

3. **テスト手法とツール**
   - 採用する技法
   - 使用するツール

4. **スケジュールとリソース**
   - テスト期間
   - 必要な人員・環境

5. **リスクと対応策**
   - テストのリスク
   - 軽減策

### テストピラミッド

```
        /\
       /  \     E2E（少数）
      /____\
     /      \   統合テスト（中程度）
    /________\
   /          \ 単体テスト（多数・高速）
  /____________\
```

**原則：**
- 🏃 **高速なテストを多く：** 単体テストは秒単位
- 💰 **コスト効率：** 単体テストが最も安価
- 🐛 **早期発見：** 下層で多くのバグを発見
- 🎯 **E2Eは重要シナリオのみ：** 遅くて壊れやすい

### テスト自動化戦略

#### 自動化すべきテスト

✅ **自動化推奨：**
- 🔄 繰り返し実行されるテスト
- 📊 リグレッションテスト
- 💨 時間のかかるテスト（性能テスト）
- 🎯 クリティカルなパス

❌ **自動化不向き：**
- 🎨 UI/UXの主観的評価
- 🔄 頻繁に変更される画面
- 💰 一度しか実行しないテスト
- 🎭 探索的テスト

#### 自動化のROI計算

**ROI = (手動実行コスト × 実行回数 - 自動化コスト) / 自動化コスト**

**例：**
- 手動実行：1時間 × 時給5000円 = 5000円
- 実行頻度：週5回 × 52週 × 3年 = 780回
- 手動総コスト：5000円 × 780回 = 390万円
- 自動化コスト：40時間 × 時給5000円 = 20万円
- ROI = (390万 - 20万) / 20万 = 1850%

### テスト環境戦略

#### 環境の種類

| 環境 | 用途 | 特徴 |
|------|------|------|
| **開発環境** | 開発者の個別開発 | 頻繁な変更 |
| **統合環境** | チーム内の統合 | 自動テスト実行 |
| **QA環境** | QAチームのテスト | 本番に近い構成 |
| **ステージング環境** | 本番前の最終確認 | 本番と同一構成 |
| **本番環境** | 実運用 | 高可用性・監視 |

#### 環境管理のベストプラクティス

- 🐳 **コンテナ化：** Docker、Kubernetesで環境を標準化
- 🤖 **IaC：** Terraform、CloudFormationで環境を自動構築
- 📊 **環境の差分最小化：** 本番に近い環境でテスト
- 🗑️ **クリーンアップ：** テストデータの自動削除

## テストデータ管理

### テストデータの種類

1. **マスターデータ**
   - 商品マスター、顧客マスター
   - 環境構築時に投入

2. **トランザクションデータ**
   - テストケースごとに作成
   - テスト終了後にクリーンアップ

3. **エッジケースデータ**
   - 境界値、異常値
   - バグ発見に重要

### テストデータの作成手法

| 手法 | 説明 | メリット | デメリット |
|------|------|----------|-----------|
| **本番データのコピー** | 本番DBをマスク化してコピー | リアル | 個人情報リスク |
| **手動作成** | テストケースに合わせて作成 | 正確 | 時間がかかる |
| **自動生成** | ツールで大量データ生成 | 大量データ | リアリティ不足 |
| **モック/スタブ** | テストダブルで代用 | 高速・独立 | 統合テスト不可 |

### 個人情報のマスキング

**手法：**
- 🔒 **匿名化：** 個人を特定できないように変換
- 🎭 **仮名化：** 仮名に置き換え
- 🌫️ **マスキング：** 一部を伏せ字（***）

## 欠陥（バグ）管理

### バグのライフサイクル

```
新規 → 割当 → 修正中 → 修正完了 → 検証中 → クローズ
                ↓                        ↓
              却下                    再オープン
```

### バグ報告の要素

**必須項目：**
1. **タイトル：** 簡潔な要約
2. **再現手順：** ステップバイステップ
3. **期待結果：** あるべき動作
4. **実際の結果：** 実際に起きたこと
5. **環境：** OS、ブラウザ、バージョン
6. **重要度・優先度：** 影響度と緊急性

**添付：**
- 📸 スクリーンショット
- 📹 動画
- 📝 ログファイル

### バグの重要度と優先度

**重要度（Severity）：** システムへの影響

| レベル | 説明 | 例 |
|--------|------|---|
| 🔴 **Critical** | システム停止 | サーバーダウン |
| 🟠 **High** | 主要機能が使えない | 決済ができない |
| 🟡 **Medium** | 機能に問題あり | 一部表示崩れ |
| 🟢 **Low** | 軽微な問題 | 誤字脱字 |

**優先度（Priority）：** 修正の緊急性

- 🚨 **P1（緊急）：** 即座に修正
- 🔥 **P2（高）：** 次リリースまでに修正
- 📊 **P3（中）：** 時間があれば修正
- 💤 **P4（低）：** 将来対応を検討

**判断例：**
- Critical + P1：決済処理が停止 → 即修正
- Low + P2：トップページの誤字 → 目立つので次リリースで修正
- High + P3：管理画面の不具合 → 回避策あり、優先度低

## 品質メトリクスと管理

### プロセスメトリクス

| メトリクス | 説明 | 目標例 |
|-----------|------|--------|
| **欠陥検出率** | テストで発見したバグ数 | フェーズごとに増加 |
| **欠陥密度** | 1KLOCあたりのバグ数 | < 1件/KLOC |
| **テストケース進捗** | 実行済み/全体 | 毎日更新 |
| **テストカバレッジ** | コードカバレッジ | > 80% |

### プロダクトメトリクス

| メトリクス | 説明 | 目標例 |
|-----------|------|--------|
| **未解決バグ数** | オープンなバグの数 | トレンドで評価 |
| **バグ修正率** | 修正済み/全体 | > 95% |
| **重大バグ数** | Critical/High | = 0（リリース時） |
| **欠陥流出率** | 本番で発見されたバグ率 | < 5% |

### リリース判定基準

**Go/No-Go判断：**

✅ **Go条件：**
- Critical/Highバグ = 0件
- テストケース実行率 = 100%
- コードカバレッジ > 80%
- 性能要件を満たす
- セキュリティスキャン合格

❌ **No-Go条件：**
- Critical/Highバグが残存
- 重要シナリオのテスト未完了
- 性能目標未達
- セキュリティ脆弱性あり

## テストの自動化ツール

### ツールの種類

| カテゴリ | ツール例 | 用途 |
|---------|---------|------|
| **単体テスト** | JUnit, pytest, Jest | 開発者テスト |
| **E2Eテスト** | Selenium, Playwright, Cypress | UI自動化 |
| **APIテスト** | Postman, REST Assured | API検証 |
| **性能テスト** | JMeter, Gatling, k6 | 負荷テスト |
| **セキュリティ** | OWASP ZAP, SonarQube | 脆弱性スキャン |
| **テスト管理** | TestRail, Zephyr, Xray | テストケース管理 |

💡 **品質は「テストで作る」のではなく「プロセス全体で作り込む」ものです。早期からのテスト設計、継続的なテスト実行、自動化による効率化、そしてメトリクスによる可視化により、持続可能な品質を実現します。**$CONTENT$,
    6,
    NOW()
  ) RETURNING id INTO v_lesson_id;

  -- Lesson 6: Questions (ひっかけ問題スタイル)
  INSERT INTO questions (lesson_id, type, question, options, correct_answer, explanation, "order", created_at)
  VALUES
    (v_lesson_id, 'multiple-choice', 'テストピラミッドで「単体テストを最も多く作成すべき」理由として最も本質的なものはどれですか？',
     ARRAY['単体テストは実装が簡単で、誰でも書けるため', '実行速度が速く、フィードバックが早いため、開発効率が高い', '単体テストだけで全ての品質を担保できるため', 'テストカバレッジ指標を高めることができるため'],
     ARRAY['実行速度が速く、フィードバックが早いため、開発効率が高い'],
     'A、C、Dはテストピラミッドの本質的理由ではありません。Aは簡単さが理由ではなく、Cは単体テストだけでは不十分（統合・E2Eも必要）、Dはカバレッジは手段であり目的ではありません。Bが正解で、単体テストは秒単位で実行でき、バグを即座にフィードバックできるため、開発者の生産性が向上します。E2Eは分単位〜時間単位かかり、フィードバックが遅れます。速さがピラミッドの基盤となる理由です。',
     1, NOW()),
    (v_lesson_id, 'multiple-answer', 'テスト自動化を「見送るべき」ケースとして適切なものを全て選択してください。',
     ARRAY['リグレッションテストとして毎週実行される重要な機能のテスト', 'プロトタイプ段階で、UI仕様が毎日変更されている画面のテスト', '一度だけ実行される、データ移行の検証テスト', '手動で5分、自動化に80時間かかり、年間10回しか実行しないテスト'],
     ARRAY['プロトタイプ段階で、UI仕様が毎日変更されている画面のテスト', '一度だけ実行される、データ移行の検証テスト', '手動で5分、自動化に80時間かかり、年間10回しか実行しないテスト'],
     'Aは典型的な自動化対象（繰り返し実行）です。B、C、Dが自動化を見送るべきケースです。Bは変更が頻繁で自動化の保守コストが高い、Cは1回だけなので投資回収できない、Dは手動5分×10回=50分に対し自動化80時間は明らかにROI不足です。自動化は「繰り返し実行される」かつ「安定している」テストに適用すべきで、全てのテストを自動化するのは誤りです。',
     2, NOW()),
    (v_lesson_id, 'multiple-choice', 'バグの「重要度（Severity）」と「優先度（Priority）」の関係で最も適切な説明はどれですか？',
     ARRAY['重要度と優先度は常に一致すべきで、Criticalバグは必ずP1で対応する', '重要度はシステムへの影響、優先度は修正の緊急性であり、必ずしも一致しない', '優先度は重要度よりも上位概念であり、優先度だけで判断すればよい', '重要度はエンジニアが決め、優先度はプロダクトオーナーが決めるものである'],
     ARRAY['重要度はシステムへの影響、優先度は修正の緊急性であり、必ずしも一致しない'],
     'Bが正解です。例えば「管理画面のCriticalバグだが回避策があり一般ユーザーに影響なし」なら重要度High/優先度P3もあり得ます。逆に「トップページの誤字（重要度Low）だが全ユーザーに見えるので即修正（優先度P1）」もあります。Aの「常に一致」は硬直的、Cの「優先度だけで判断」は影響度を無視、Dの役割分担は一部正しいが絶対的なルールではありません。重要度と優先度は異なる軸です。',
     3, NOW()),
    (v_lesson_id, 'multiple-answer', 'リリース判定会議で「条件付きGo」を出すべき状況を全て選択してください。',
     ARRAY['Mediumバグが3件残っているが、いずれも軽微で回避策が文書化されている', 'Critical バグが1件残っているが、発生確率が低く、発生時の対応手順が確立している', 'テストカバレッジが75%だが、重要な機能は100%カバーされている', '性能目標が未達だが、初期ユーザー数が少ないため問題ないと判断される'],
     ARRAY['Mediumバグが3件残っているが、いずれも軽微で回避策が文書化されている', 'テストカバレッジが75%だが、重要な機能は100%カバーされている', '性能目標が未達だが、初期ユーザー数が少ないため問題ないと判断される'],
     'A、C、Dは条件付きGoが妥当です（軽微で管理可能なリスク）。しかしBのCriticalバグは、発生確率が低くても影響が重大なため、リリース前に修正すべきです。「発生確率×影響度」でリスク評価しますが、Criticalは影響度が極めて高いため、発生確率が低くてもリスクが高いと判断されます。条件付きGoは「軽微なリスク」に限定し、Criticalな問題は残してはいけません。',
     4, NOW()),
    (v_lesson_id, 'multiple-choice', 'テストデータに本番データのコピーを使用する際、最も重要な対応はどれですか？',
     ARRAY['本番データをそのままコピーし、リアルなテストデータとして活用する', '個人情報を匿名化・マスキングしてから使用し、プライバシーを保護する', 'テスト環境のアクセス権を厳格に管理し、限られた人だけがアクセスできるようにする', '本番データのコピーは禁止し、必ず手動でテストデータを作成する'],
     ARRAY['個人情報を匿名化・マスキングしてから使用し、プライバシーを保護する'],
     'Bが正解です。本番データには個人情報が含まれるため、テスト環境にそのままコピーすることは法令違反（GDPR、個人情報保護法）やセキュリティリスクになります。Aは論外、Cのアクセス制限は必要ですが根本的解決ではなく、Dの全面禁止は現実的でなく（リアルなデータが必要な場合もある）バランスを欠きます。匿名化・マスキングにより、リアルさを保ちつつプライバシーを保護するのがベストプラクティスです。',
     5, NOW());

END $$;
