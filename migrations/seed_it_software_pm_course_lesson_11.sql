-- IT・ソフトウェア開発プロジェクトマネジメントコース
-- Lesson 11: 技術的負債とリファクタリング戦略

DO $$
DECLARE
  v_course_id INT;
  v_lesson_id INT;
BEGIN
  -- Get course ID
  SELECT id INTO v_course_id FROM courses WHERE slug = 'it-software-pm';

  -- Lesson 11: 技術的負債とリファクタリング戦略
  INSERT INTO lessons (course_id, slug, title, content, "order", created_at)
  VALUES (
    v_course_id,
    'technical-debt-refactoring',
    '技術的負債とリファクタリング戦略',
    $CONTENT$# 技術的負債とリファクタリング戦略

技術的負債は**短期的な開発速度のために長期的な品質を犠牲にすること**であり、適切な管理が持続可能な開発の鍵です。

## 技術的負債とは

### 技術的負債のメタファー

**Ward Cunninghamの定義：**
> 不完全なコードを出荷することは、金銭的な負債を負うことに似ている。
> 少額の負債は開発を加速するが、利息（保守コスト）を払い続けなければならず、
> 返済（リファクタリング）しなければ破綻する。

### 負債の構成要素

```
技術的負債 = 元本 + 利息

元本：問題のあるコードそのもの
利息：そのコードを保持し続けることによる継続的なコスト
  - 機能追加に時間がかかる
  - バグが発生しやすい
  - 新メンバーの理解に時間がかかる
```

## 技術的負債の分類

### マーチン・ファウラーの技術的負債マトリクス

```
        意図的
         ↑
    無謀 | 慎重
 ───────┼───────
    無謀 | 慎重
         ↓
       偶発的
```

#### 1. 慎重・意図的な負債

**特徴：**
- 🎯 ビジネス判断として意識的に選択
- 📊 負債の存在と影響を理解
- 📝 返済計画がある

**例：**
- 市場投入を急ぐため、一時的に設計を簡略化
- 「今は動くコードを優先、後でリファクタリングする」

**管理：** 負債として記録し、スケジュールに返済を組み込む

#### 2. 慎重・偶発的な負債

**特徴：**
- 💡 実装後により良い設計に気づく
- 📚 知識の進化による負債

**例：**
- 「リリース後、もっと良い設計パターンがあることに気づいた」

**管理：** 学習の結果として受け入れ、継続的に改善

#### 3. 無謀・意図的な負債

**特徴：**
- 😓 設計の重要性を理解せず無視
- 📅 「時間がないから設計を飛ばす」

**例：**
- 設計レビューを省略
- テストを書かずにリリース

**管理：** 組織文化の問題。教育と啓蒙が必要

#### 4. 無謀・偶発的な負債

**特徴：**
- 🚫 スキル不足や経験不足
- 😓 悪いコードと気づかない

**例：**
- デザインパターンを知らずに複雑なコードを書く

**管理：** トレーニング、コードレビュー、ペアプログラミング

### 技術的負債の原因

| カテゴリ | 原因 | 例 |
|---------|------|---|
| **ビジネス圧力** | 納期優先、機能優先 | リリース日固定 |
| **設計不足** | アーキテクチャの欠如 | モノリシックな肥大化 |
| **スキル不足** | 技術力の不足 | アンチパターンの採用 |
| **変更の蓄積** | パッチの継ぎ接ぎ | スパゲッティコード |
| **ドキュメント不足** | 仕様が不明確 | コードを読まないと分からない |
| **テスト不足** | 自動テストなし | 変更が怖い |
| **技術の陳腐化** | ライブラリの古さ | サポート終了の依存 |

## 技術的負債の測定と可視化

### 負債の測定手法

#### 1. 静的解析ツール

**メトリクス：**

| メトリクス | 説明 | ツール |
|-----------|------|--------|
| **コード複雑度** | サイクロマティック複雑度 | SonarQube, CodeClimate |
| **重複コード** | コードクローンの検出 | SonarQube, CPD |
| **コードスメル** | 問題のあるパターン | SonarQube, ESLint |
| **テストカバレッジ** | テストされていないコード | Jest, pytest-cov |

**SonarQubeの「技術的負債時間」：**
- 問題を修正するのに必要な時間を推定
- 例：「技術的負債 120時間」

#### 2. 負債レジスタ

**管理項目：**

| 項目 | 説明 |
|------|------|
| **負債ID** | 一意の識別子 |
| **説明** | 何が問題か |
| **場所** | ファイル、モジュール |
| **発生理由** | なぜ負債となったか |
| **影響度** | 高/中/低 |
| **返済コスト** | 修正に必要な時間 |
| **利息コスト** | 放置した場合の月次コスト |
| **優先度** | いつ対応するか |

#### 3. コードの鮮度（Code Age）

**測定：**
- 📅 最終変更日からの経過時間
- 🔥 変更頻度が高く古いコード = 高リスク

**ヒートマップ：**
```
[HOT]  頻繁に変更 × 複雑  → 最優先でリファクタリング
[WARM] 頻繁に変更 × 単純  → 問題なし
[COOL] 変更少ない × 複雑  → 監視
[COLD] 変更少ない × 単純  → 放置可
```

## リファクタリング戦略

### リファクタリングとは

**定義：** 外部から見た動作を変えずに、内部構造を改善すること

**重要：**
- ✅ 機能追加ではない
- ✅ バグ修正ではない
- ✅ コードの品質改善

### リファクタリングのタイミング

#### ボーイスカウトルール

> 「来た時よりも美しく」

**実践：**
- 🔧 コードに触れる度に少しだけ改善
- 📝 大規模なリファクタリングではなく継続的な改善
- ✅ 日常的な習慣として定着

#### 計画的リファクタリング

**実施タイミング：**
- 📅 スプリント内にリファクタリング時間を確保
- 🎯 技術的負債返済スプリント
- 📊 負債の利息が高くなる前

**予算配分例：**
- 新機能開発：70%
- バグ修正：20%
- リファクタリング：10%

### リファクタリングの優先順位付け

#### 負債の優先度マトリクス

```
      高影響
       ↑
   P1  |  P0
低────┼────高  修正コスト
   P3  |  P2
       ↓
      低影響
```

**優先順位：**
- **P0（即対応）：** 影響大 × 修正容易
- **P1（計画的）：** 影響大 × 修正困難
- **P2（機会があれば）：** 影響小 × 修正容易
- **P3（放置）：** 影響小 × 修正困難

#### ROI（投資対効果）

**計算：**
```
ROI = (削減される年間コスト - リファクタリングコスト) / リファクタリングコスト

例：
- リファクタリングコスト：80時間
- 削減される月間コスト：20時間（年間240時間）
- ROI = (240 - 80) / 80 = 2.0（200%）
```

### リファクタリングの手法

#### 1. 小規模リファクタリング

**変数名の改善：**
```javascript
// Before
const d = new Date();

// After
const currentDate = new Date();
```

**関数の抽出：**
```javascript
// Before
function processOrder(order) {
  // 注文の検証（10行）
  // 在庫確認（15行）
  // 決済処理（20行）
  // 通知送信（10行）
}

// After
function processOrder(order) {
  validateOrder(order);
  checkInventory(order);
  processPayment(order);
  sendNotification(order);
}
```

#### 2. 中規模リファクタリング

**クラスの抽出：**
- 肥大化したクラスを複数に分割
- 単一責任の原則（SRP）を適用

**デザインパターンの適用：**
- Strategy、Factory、Observerなどの導入
- 柔軟性と保守性の向上

#### 3. 大規模リファクタリング

**アーキテクチャの刷新：**
- モノリスからマイクロサービスへ
- レイヤードアーキテクチャの導入

**レガシーシステムの段階的移行：**

**ストラングラーパターン：**
```
旧システム         新システム
  100%    →    90%  |  10%
           →    50%  |  50%
           →    10%  |  90%
           →     0%  | 100%
```

- 段階的に新システムへ移行
- 旧システムを徐々に「絞め殺す」

## リファクタリングの実践

### 安全なリファクタリング

#### 1. テストファースト

**手順：**
1. ✅ 既存のテストが全て通ることを確認
2. 🔧 リファクタリング実施
3. ✅ テストが全て通ることを再確認

**重要：** テストがない場合は、まずテストを書く

#### 2. 小さなステップ

**原則：**
- 🐾 一度に一つずつ変更
- ✅ 各ステップでテスト
- 💾 こまめにコミット

**利点：**
- 問題発生時に戻しやすい
- レビューしやすい
- 心理的負担が少ない

#### 3. コードレビュー

**確認事項：**
- ✅ 動作が変わっていないか
- ✅ 可読性が向上しているか
- ✅ パフォーマンスが劣化していないか
- ✅ テストが充分か

### リファクタリングツール

| 言語 | IDE/ツール | 機能 |
|------|-----------|------|
| **Java** | IntelliJ IDEA | 変数名変更、メソッド抽出、クラス抽出 |
| **JavaScript/TypeScript** | VSCode | リネーム、リファクタリング提案 |
| **Python** | PyCharm | 自動リファクタリング |
| **C#** | Visual Studio | コード分析、自動修正 |

## 技術的負債の予防

### 1. コーディング規約

**目的：** 一貫性のあるコードベース

**内容：**
- 📝 命名規則
- 🎨 フォーマット（Prettier、Black）
- 📚 コメント規約
- 🏗️ アーキテクチャガイドライン

**自動化：** Linter、Formatter の CI 組み込み

### 2. コードレビューの徹底

**チェック項目：**
- ✅ 単一責任の原則
- ✅ DRY（Don't Repeat Yourself）
- ✅ KISS（Keep It Simple, Stupid）
- ✅ YAGNI（You Aren't Gonna Need It）

### 3. ペアプログラミング

**効果：**
- 🧑‍🤝‍🧑 リアルタイムのレビュー
- 📚 知識共有
- 🎯 品質の向上

### 4. アーキテクチャレビュー

**実施：**
- 📅 四半期ごとに全体設計を見直し
- 🔍 技術的負債の蓄積状況を確認
- 🎯 次期対応計画を策定

### 5. 技術的負債の可視化

**ダッシュボード：**
- 📊 技術的負債時間の推移
- 📈 コード複雑度のトレンド
- 🎯 高リスクモジュールの特定

## 技術的負債とビジネス

### ステークホルダーへの説明

**ビジネス言語で伝える：**

❌ **悪い例：**
「コードのサイクロマティック複雑度が高く、リファクタリングが必要です」

✅ **良い例：**
「現在、新機能の追加に通常の2倍の時間がかかっています。
 コードの整理に2週間投資すれば、今後の開発が30%速くなります」

### 負債の影響をデータで示す

**メトリクス：**
- ⏱️ **開発速度の低下：** ストーリーポイント/スプリント
- 🐛 **バグ発生率：** バグ数/機能
- 😓 **開発者満足度：** チームアンケート
- 💰 **保守コスト：** 月間の修正時間

### エンジニアリング時間の確保

**交渉：**
- 📊 データで必要性を示す
- 🎯 具体的な改善目標を提示
- 💰 ROIを計算
- ⏰ 段階的な実施計画

**例：**
「スプリントの10%（1日/2週間）を技術的負債返済に充てることで、
 3ヶ月後には開発速度が20%向上すると予測されます」

## 技術的負債の文化

### 負債を受け入れる文化

**原則：**
- 🚫 負債はゼロにできない（する必要もない）
- ⚖️ 適切なバランスを保つ
- 📊 負債を可視化し、管理する
- 🔄 継続的に返済する

### チームの合意形成

**Definition of Done（DoD）に組み込む：**
```
完成の定義：
- ✅ テストカバレッジ80%以上
- ✅ コードレビュー承認
- ✅ Linterエラーゼロ
- ✅ 複雑度が閾値以下
- ✅ ドキュメント更新
```

### 負債返済の習慣化

**実践：**
- 🎯 毎スプリントに返済タスクを含める
- 📅 月1回の「負債返済デー」
- 🏆 リファクタリングの成果を称賛

💡 **技術的負債は悪ではなく、トレードオフの結果です。重要なのは負債を認識し、計画的に管理し、適切なタイミングで返済すること。これにより、短期的な速度と長期的な持続可能性のバランスを保てます。**$CONTENT$,
    11,
    NOW()
  ) RETURNING id INTO v_lesson_id;

  -- Lesson 11: Questions (ひっかけ問題スタイル)
  INSERT INTO questions (lesson_id, type, question, options, correct_answer, explanation, "order", created_at)
  VALUES
    (v_lesson_id, 'multiple-choice', '技術的負債マトリクスで「慎重・意図的な負債」として適切なものはどれですか？',
     ARRAY['市場投入を急ぐため、一時的に設計を簡略化し、後でリファクタリングする計画を立てた', '設計の重要性を理解せず、時間がないという理由で設計レビューを省略した', 'デザインパターンを知らずに、複雑で保守しにくいコードを書いてしまった', '実装後により良い設計があることに気づいたが、当初は最善を尽くしていた'],
     ARRAY['市場投入を急ぐため、一時的に設計を簡略化し、後でリファクタリングする計画を立てた'],
     'Aが正解です。「慎重・意図的」は、ビジネス判断として意識的に負債を選択し、その存在を認識し、返済計画がある状態です。Bは「無謀・意図的」（設計の重要性を無視）、Cは「無謀・偶発的」（スキル不足）、Dは「慎重・偶発的」（学習の結果）です。技術的負債は必ずしも悪ではなく、Aのように戦略的に使えば有効なツールですが、返済計画がないと破綻します。',
     1, NOW()),
    (v_lesson_id, 'multiple-answer', 'リファクタリングの優先順位を決める際に考慮すべき要素を全て選択してください。',
     ARRAY['そのコードが変更される頻度（変更頻度が高いほど優先）', 'そのコードが書かれた日付（古いコードほど優先）', 'リファクタリングによって削減されるコスト（利息）', 'リファクタリングに必要な工数（修正コスト）'],
     ARRAY['そのコードが変更される頻度（変更頻度が高いほど優先）', 'リファクタリングによって削減されるコスト（利息）', 'リファクタリングに必要な工数（修正コスト）'],
     'A、C、Dが考慮すべき要素です。Aの変更頻度は重要で、頻繁に触れるコードほど影響が大きい。CとDでROI計算（削減コスト/修正コスト）ができます。Bの「古いコード」は誤解で、古くても変更されないコードは優先度低です。重要なのは「頻繁に変更される×複雑」なコードです。コードの年齢ではなく、チームへの影響度で優先順位を決めるべきです。',
     2, NOW()),
    (v_lesson_id, 'multiple-choice', 'ボーイスカウトルール（「来た時よりも美しく」）を実践する最も適切な方法はどれですか？',
     ARRAY['コードに触れる度に、そのファイル全体を完全にリファクタリングする', 'バグ修正や機能追加の際に、触れた部分を少しだけ改善する習慣をつける', '毎週金曜日をリファクタリングデーとして、チーム全体でコードを改善する', 'リファクタリングは専門のチームが行うべきで、通常の開発者は触らない'],
     ARRAY['バグ修正や機能追加の際に、触れた部分を少しだけ改善する習慣をつける'],
     'Bが正解です。ボーイスカウトルールは「日常的な小さな改善の積み重ね」です。Aの全体リファクタリングは大きすぎて実践困難、Cの計画的リファクタリングデーも有効ですがボーイスカウトルールとは異なる、Dは間違いで全員がコードの品質に責任を持つべきです。重要なのは「継続性」と「習慣化」で、大きな改善ではなく、触れた箇所を少しだけ良くする積み重ねが長期的に効果を発揮します。',
     3, NOW()),
    (v_lesson_id, 'multiple-answer', '安全にリファクタリングを行うために必須の条件を全て選択してください。',
     ARRAY['既存の機能を検証する自動テストが存在する', 'リファクタリングの前後で全てのテストが成功する', 'リファクタリング作業を一度に全て完了させる', '小さなステップで変更し、各ステップでテストを実行する'],
     ARRAY['既存の機能を検証する自動テストが存在する', 'リファクタリングの前後で全てのテストが成功する', '小さなステップで変更し、各ステップでテストを実行する'],
     'A、B、Dが必須条件です。リファクタリングは「外部動作を変えずに内部を改善」するため、自動テストで動作を保証することが前提（A）。リファクタリング後もテストが通ること（B）と、小さなステップで進める（D）ことで安全性を確保します。Cは誤りで、一度に全て完了は危険です。テストなしでのリファクタリングは「動いているかも分からない状態で変更する」ことであり、非常にリスキーです。',
     4, NOW()),
    (v_lesson_id, 'multiple-choice', '技術的負債をステークホルダーに説明する際、最も効果的なアプローチはどれですか？',
     ARRAY['「コードのサイクロマティック複雑度が高く、クラスの凝集度が低いため、リファクタリングが必要です」と技術的に正確に説明する', '「現在、新機能開発に通常の2倍の時間がかかっています。2週間の改善で今後30%速くなります」とビジネス影響とROIで説明する', '「エンジニアのモチベーションが下がっているため、リファクタリング時間が必要です」と感情的に訴える', '「他社もリファクタリングをやっているので、うちもやるべきです」と業界のトレンドで説明する'],
     ARRAY['「現在、新機能開発に通常の2倍の時間がかかっています。2週間の改善で今後30%速くなります」とビジネス影響とROIで説明する'],
     'Bが正解です。ステークホルダーは技術的詳細ではなく、ビジネスへの影響を理解する必要があります。Bは「現状の問題」「投資額」「期待される成果」を明確に示し、意思決定に必要な情報を提供します。Aの技術用語は非技術者に伝わらず、Cの感情的訴えは説得力不足、Dのトレンドは根拠が弱いです。技術的負債をビジネス言語に翻訳することがPMの重要なスキルです。',
     5, NOW());

END $$;
