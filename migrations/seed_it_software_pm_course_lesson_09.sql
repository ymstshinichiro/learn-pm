-- IT・ソフトウェア開発プロジェクトマネジメントコース
-- Lesson 9: リリースマネジメントとデプロイ戦略

DO $$
DECLARE
  v_course_id INT;
  v_lesson_id INT;
BEGIN
  -- Get course ID
  SELECT id INTO v_course_id FROM courses WHERE slug = 'it-software-pm';

  -- Lesson 9: リリースマネジメントとデプロイ戦略
  INSERT INTO lessons (course_id, slug, title, content, "order", created_at)
  VALUES (
    v_course_id,
    'release-deployment-strategy',
    'リリースマネジメントとデプロイ戦略',
    $CONTENT$# リリースマネジメントとデプロイ戦略

リリースは単なる「コードを本番に上げる」作業ではなく、**ビジネス価値を安全に届ける戦略的プロセス**です。

## リリースとデプロイの違い

### 用語の明確化

| 用語 | 意味 | タイミング |
|------|------|-----------|
| **デプロイ** | コードを環境に配置する技術的作業 | 頻繁（1日複数回も可） |
| **リリース** | 機能をユーザーに公開するビジネス判断 | 計画的（週次〜月次など） |

**重要な概念：** デプロイとリリースを分離することで、柔軟性とリスク管理が向上

**例：**
- 🚀 **デプロイ：** 新機能のコードを本番環境に配置（フィーチャーフラグでOFF）
- 🎯 **リリース：** マーケティングのタイミングに合わせてフィーチャーフラグをON

## デプロイ戦略

### 1. ビッグバンデプロイ（一括切り替え）

**方法：**
- 🔄 旧バージョンを停止
- 🚀 新バージョンをデプロイ
- ✅ 起動・確認

**メリット：**
- ✅ シンプルで理解しやすい
- ✅ 実装が容易

**デメリット：**
- ❌ ダウンタイムが発生
- ❌ 問題発生時の影響が大きい
- ❌ ロールバックに時間がかかる

**適用場面：**
- 📊 小規模システム
- 🌙 深夜メンテナンス可能
- 👥 ユーザー数が少ない

### 2. ローリングデプロイ

**方法：**
```
[V1] [V1] [V1] [V1]  ← 初期状態
  ↓
[V2] [V1] [V1] [V1]  ← サーバー1をV2に
  ↓
[V2] [V2] [V1] [V1]  ← サーバー2をV2に
  ↓
[V2] [V2] [V2] [V2]  ← 全サーバーがV2
```

**メリット：**
- ✅ ダウンタイムなし
- ✅ 段階的な切り替えでリスク分散
- ✅ 問題発見時に残りを停止可能

**デメリット：**
- ⚠️ 一時的にV1とV2が混在
- ⚠️ 後方互換性が必要
- ⚠️ データベーススキーマ変更が複雑

**適用場面：**
- 🌐 Webアプリケーション
- 📊 水平スケールするシステム
- 🔄 後方互換性を保てる変更

### 3. ブルーグリーンデプロイ

**方法：**
```
Blue環境（現行）     Green環境（新バージョン）
    ↓                      ↓
[V1] [V1] [V1]       [V2] [V2] [V2]
    ↓                      ↓
ロードバランサー ──→ Blue
                    ↓
             切り替え
                    ↓
ロードバランサー ──→ Green
```

**メリット：**
- ✅ 瞬時の切り替え
- ✅ 即座のロールバック（切り戻し）
- ✅ 本番同等環境でのテスト

**デメリット：**
- 💰 2倍のリソースが必要
- 📊 ステートフルな要素（DB）の扱いが複雑
- 🔄 環境の同期管理

**適用場面：**
- 💰 リソースに余裕がある
- 🎯 高可用性が求められる
- ⏱️ ダウンタイム許容ゼロ

### 4. カナリアリリース

**方法：**
```
全ユーザー: 100%
    ↓
[V1: 95%] [V2: 5%]   ← 一部ユーザーで検証
    ↓
[V1: 50%] [V2: 50%]  ← 段階的に拡大
    ↓
[V2: 100%]           ← 全ユーザー切り替え
```

**メリット：**
- ✅ 実ユーザーでの段階的検証
- ✅ 問題の影響範囲を最小化
- ✅ パフォーマンスの実測

**デメリット：**
- ⚠️ ユーザー体験の差異
- 📊 複雑な監視・分析が必要
- 🔄 セッション管理の考慮

**適用場面：**
- 🎯 リスクの高い変更
- 📱 大規模ユーザーベース
- 📊 A/Bテスト実施

### 5. フィーチャーフラグ（機能トグル）

**方法：**
```python
if feature_flag_enabled("new_checkout"):
    return new_checkout_flow()
else:
    return old_checkout_flow()
```

**種類：**

| 種類 | 用途 | ライフサイクル |
|------|------|---------------|
| **リリースフラグ** | 機能の段階的公開 | 短期（削除予定） |
| **実験フラグ** | A/Bテスト | 実験期間のみ |
| **運用フラグ** | システム動作の制御 | 長期 |
| **権限フラグ** | ユーザー種別で機能制御 | 長期 |

**メリット：**
- ✅ デプロイとリリースの分離
- ✅ 段階的ロールアウト
- ✅ 即座のロールバック（コード不要）
- ✅ A/Bテストの実施

**デメリット：**
- ⚠️ コードの複雑性増加
- 🧹 フラグの削除忘れ（技術的負債）
- 🐛 全パターンのテストが困難

**ベストプラクティス：**
- 🗑️ 不要なフラグは即座に削除
- 📝 フラグの目的と期限を文書化
- 🧪 フラグのON/OFF両パターンをテスト

## リリース計画

### リリースの種類

| 種類 | 頻度 | 内容 | 例 |
|------|------|------|---|
| **メジャーリリース** | 年1-2回 | 大きな機能追加・変更 | v2.0.0 |
| **マイナーリリース** | 月1-2回 | 新機能・改善 | v1.5.0 |
| **パッチリリース** | 週次〜随時 | バグ修正 | v1.4.3 |
| **ホットフィックス** | 緊急時 | 重大な不具合の修正 | v1.4.4 |

### リリース計画の要素

#### 1. リリースノート

**含めるべき内容：**

```markdown
# Version 2.5.0 - 2024-03-15

## 新機能 (New Features)
- 🎉 ダークモードに対応
- 📊 分析ダッシュボードを追加

## 改善 (Improvements)
- ⚡ 検索速度を50%向上
- 🎨 UI/UXを改善

## バグ修正 (Bug Fixes)
- 🐛 ログイン時のセッションタイムアウト問題を修正
- 🐛 画像アップロード時のエラーを修正

## 破壊的変更 (Breaking Changes)
- ⚠️ API v1 を廃止（v2への移行が必要）

## 既知の問題 (Known Issues)
- 📝 IE11でのレイアウト崩れ（次回修正予定）

## アップグレード手順
1. データベースマイグレーション実行: `npm run migrate`
2. 環境変数 NEW_API_KEY を設定
3. サーバー再起動
```

#### 2. コミュニケーション計画

**ステークホルダー別の通知：**

| 対象 | タイミング | 内容 |
|------|-----------|------|
| **経営層** | 1週間前 | ビジネス影響、KPI予測 |
| **営業・CS** | 3日前 | 新機能説明、顧客対応準備 |
| **エンドユーザー** | 1日前 | 新機能・変更点の案内 |
| **開発チーム** | 当日 | 技術的詳細、監視項目 |

#### 3. ロールバック計画

**ロールバック判断基準：**
- 🚨 重大なバグ（データ損失、セキュリティ）
- 📉 主要KPIの大幅な低下（CV率、応答時間）
- 💥 システムの不安定化

**ロールバック手順：**
1. 📊 問題の確認と影響範囲の特定
2. ✅ ロールバック実行の承認取得
3. 🔄 切り戻し実行
4. 🧪 動作確認
5. 📢 関係者への通知

**データベースロールバック：**
- ⚠️ **前方互換性：** 新バージョンから旧バージョンへの切り戻しを考慮
- 📊 **マイグレーション戦略：** Expand-Contract パターン

```
Expand: 新旧両方のカラムを追加
    ↓
Migrate: データを新カラムにコピー
    ↓
Contract: 旧カラムを削除（別リリースで）
```

## リリース環境管理

### 環境の進行フロー

```
開発環境 → 統合環境 → QA環境 → ステージング環境 → 本番環境
  ↓          ↓          ↓           ↓              ↓
自動テスト  自動テスト  手動テスト   最終確認      監視・観測
```

### 環境ごとの目的

| 環境 | 目的 | データ | 構成 |
|------|------|--------|------|
| **開発** | 機能開発 | ダミー | 簡易 |
| **統合** | チーム統合 | ダミー | 簡易 |
| **QA** | 品質検証 | テスト | 本番に近い |
| **ステージング** | 最終確認 | 本番コピー | 本番同一 |
| **本番** | 実運用 | 実データ | 本番 |

### インフラストラクチャ as Code (IaC)

**ツール：**
- 🔧 **Terraform：** マルチクラウド対応
- ☁️ **CloudFormation：** AWS専用
- 🐳 **Docker Compose / Kubernetes：** コンテナオーケストレーション

**メリット：**
- ✅ 環境の再現性
- ✅ バージョン管理
- ✅ レビュー可能
- ✅ 自動化

## リリース自動化とCI/CD

### 継続的インテグレーション（CI）

**プロセス：**
1. 📝 コードをコミット
2. 🚀 自動ビルド
3. 🧪 自動テスト実行
4. 📊 結果通知

**CI/CDツール：**
- GitHub Actions
- GitLab CI/CD
- Jenkins
- CircleCI
- Travis CI

### 継続的デリバリー（CD）

**プロセス：**
1. ✅ CIパス
2. 🚀 ステージング環境へ自動デプロイ
3. 🧪 統合テスト実行
4. 👤 手動承認
5. 🚀 本番環境へデプロイ

### 継続的デプロイ（Continuous Deployment）

**継続的デリバリーとの違い：**
- 継続的デリバリー：本番デプロイは手動承認
- 継続的デプロイ：本番デプロイも完全自動

**適用条件：**
- ✅ 高いテスト自動化率
- ✅ 堅牢な監視体制
- ✅ 即座のロールバック機能
- ✅ チームの成熟度

## リリース後の監視

### 可観測性（Observability）の3本柱

#### 1. メトリクス（Metrics）

**システムメトリクス：**
- 📊 CPU、メモリ使用率
- 🌐 ネットワークトラフィック
- 💾 ディスクI/O

**アプリケーションメトリクス：**
- ⏱️ レスポンスタイム
- 🔢 リクエスト数（RPS）
- ❌ エラー率
- 📈 ビジネスKPI（CV率、売上など）

**ツール：** Prometheus、Grafana、Datadog、New Relic

#### 2. ログ（Logs）

**構造化ログ：**
```json
{
  "timestamp": "2024-03-15T10:30:00Z",
  "level": "ERROR",
  "service": "payment-api",
  "message": "Payment processing failed",
  "user_id": "12345",
  "transaction_id": "tx-67890",
  "error_code": "INSUFFICIENT_FUNDS"
}
```

**集約・分析ツール：**
- ELK Stack (Elasticsearch, Logstash, Kibana)
- Splunk
- Datadog Logs
- CloudWatch Logs

#### 3. トレース（Traces）

**分散トレーシング：**
- 🔍 リクエストの全経路を追跡
- ⏱️ 各サービスの処理時間を可視化
- 🐛 ボトルネック特定

**ツール：**
- Jaeger
- Zipkin
- OpenTelemetry

### アラートの設計

#### アラートの種類

| 種類 | 目的 | 例 |
|------|------|---|
| **症状ベース** | ユーザー影響を検知 | エラー率 > 5% |
| **原因ベース** | システム異常を検知 | CPU使用率 > 90% |

**原則：** 症状ベースを優先（ユーザー影響がない警告は不要）

#### アラート疲れの防止

**良いアラート：**
- ✅ 実際に対応が必要
- ✅ アクションが明確
- ✅ 適切な担当者へ通知

**悪いアラート：**
- ❌ 頻繁すぎて無視される
- ❌ 対応方法が不明
- ❌ 誤検知が多い

**改善方法：**
- 🎯 閾値の調整
- 📊 複数条件の組み合わせ
- ⏰ 時間帯による調整
- 🔇 メンテナンス時の通知停止

## リリース成功の測定

### デプロイメント頻度

**計測：**
- 📊 1週間あたりのデプロイ回数
- 🎯 目標：週1回以上（高パフォーマンス組織は1日複数回）

### 変更のリードタイム

**定義：** コードコミットから本番稼働までの時間

**計測：**
- ⏱️ コミット → デプロイ完了
- 🎯 目標：1日以内（高パフォーマンス組織は1時間以内）

### 変更失敗率

**定義：** 本番デプロイのうち、ロールバックが必要になる割合

**計測：**
- 📊 失敗デプロイ数 / 総デプロイ数
- 🎯 目標：15%以下（高パフォーマンス組織は5%以下）

### 平均復旧時間（MTTR）

**定義：** 障害発生から復旧までの時間

**計測：**
- ⏱️ 障害検知 → 復旧完了
- 🎯 目標：1時間以内（高パフォーマンス組織は15分以内）

### DORA Metrics（DevOps指標）

| 指標 | 低パフォーマンス | 中パフォーマンス | 高パフォーマンス |
|------|----------------|----------------|----------------|
| **デプロイ頻度** | 月1回〜半年1回 | 週1回〜月1回 | 1日複数回 |
| **リードタイム** | 6ヶ月以上 | 1週間〜1ヶ月 | 1日以内 |
| **変更失敗率** | 46-60% | 16-30% | 0-15% |
| **MTTR** | 6ヶ月以上 | 1週間〜1ヶ月 | 1時間以内 |

## リリースの成熟度モデル

### レベル1: 手動デプロイ

- 📝 手順書に従って手動実行
- ⚠️ 人的ミスのリスク高
- ⏱️ 時間がかかる

### レベル2: スクリプト化

- 🔧 デプロイスクリプトを作成
- ✅ 手順の標準化
- ⚠️ 実行は手動

### レベル3: CI/CD導入

- 🤖 自動ビルド・テスト
- 🚀 ステージングへ自動デプロイ
- 👤 本番は手動承認

### レベル4: 継続的デプロイ

- 🤖 本番デプロイも自動化
- 📊 高度な監視・自動ロールバック
- 🎯 1日複数回のリリース

💡 **リリースは「イベント」から「日常」へ。自動化と可観測性により、小さく頻繁にリリースすることで、リスクを下げながらビジネス価値を迅速に届けられます。**$CONTENT$,
    9,
    NOW()
  ) RETURNING id INTO v_lesson_id;

  -- Lesson 9: Questions (ひっかけ問題スタイル)
  INSERT INTO questions (lesson_id, type, question, options, correct_answer, explanation, "order", created_at)
  VALUES
    (v_lesson_id, 'multiple-choice', '「デプロイ」と「リリース」を分離する最も重要な理由はどれですか？',
     ARRAY['デプロイ作業とリリース作業を異なる担当者に分担できるため', 'デプロイ頻度を上げつつ、リリースタイミングはビジネス判断で制御できるため', 'デプロイとリリースの用語を正確に使い分けることで、コミュニケーションが明確になるため', 'デプロイは技術的作業、リリースはマーケティング作業として組織を分離できるため'],
     ARRAY['デプロイ頻度を上げつつ、リリースタイミングはビジネス判断で制御できるため'],
     'Bが正解です。デプロイとリリースの分離（フィーチャーフラグなどで実現）により、「技術的にコードを本番に上げる」ことと「ユーザーに機能を公開する」ことを独立させられます。これにより、デプロイは頻繁に行いつつ、リリースはマーケティング戦略や市場タイミングに合わせられます。Aの担当者分担、Cの用語統一、Dの組織分離は副次的効果であり本質ではありません。分離の本質は柔軟性とリスク管理の向上です。',
     1, NOW()),
    (v_lesson_id, 'multiple-answer', 'カナリアリリースを採用すべき状況として適切なものを全て選択してください。',
     ARRAY['アーキテクチャの大幅な変更で、パフォーマンスへの影響が未知数', '軽微なバグ修正で、影響範囲が明確で限定的', '数百万ユーザーを持つサービスでの決済システムの刷新', '社内管理ツールで、ユーザーが10名のみ'],
     ARRAY['アーキテクチャの大幅な変更で、パフォーマンスへの影響が未知数', '数百万ユーザーを持つサービスでの決済システムの刷新'],
     'AとCがカナリアリリースの適用場面です。カナリアは「リスクが高い変更」を「大規模ユーザーベース」で段階的に検証する手法です。Aは影響未知数、Cは重要システム×大規模で、両方とも段階的検証が必要です。Bの軽微なバグ修正は通常のデプロイで十分、Dの10名のみは段階的展開の意味がありません（10名全員に影響しても大きな問題にならない）。カナリアはコストがかかるため、必要な場面を見極めることが重要です。',
     2, NOW()),
    (v_lesson_id, 'multiple-choice', 'フィーチャーフラグ（機能トグル）を使用する際の最大のリスクはどれですか？',
     ARRAY['フラグのON/OFF切り替えにサーバー再起動が必要で、ダウンタイムが発生する', '不要になったフラグを削除せず放置し、コードが複雑化して技術的負債になる', 'フラグの判定処理がパフォーマンスのボトルネックになる', 'フラグの設定ミスで、全ユーザーに意図しない機能が公開される'],
     ARRAY['不要になったフラグを削除せず放置し、コードが複雑化して技術的負債になる'],
     'Bが正解です。フィーチャーフラグの最大のリスクは「削除忘れ」による技術的負債の蓄積です。古いフラグが残ると、コードの複雑性が増し、テストパターンも爆発的に増加します。Aは誤解（フラグは動的に切り替え可能でサーバー再起動不要）、Cはパフォーマンス影響は通常軽微、Dの設定ミスはリスクですが運用の問題で本質的なリスクではありません。ベストプラクティスは「フラグの目的達成後は即座に削除」です。',
     3, NOW()),
    (v_lesson_id, 'multiple-answer', 'ロールバック（切り戻し）を実行すべき判断基準として適切なものを全て選択してください。',
     ARRAY['新機能に軽微なUI表示バグがあるが、機能自体は動作している', '重大なセキュリティ脆弱性が発見され、データ漏洩のリスクがある', 'エラー率が通常0.1%から5%に急増し、多数のユーザーに影響', 'パフォーマンスが期待より10%低いが、要件は満たしている'],
     ARRAY['重大なセキュリティ脆弱性が発見され、データ漏洩のリスクがある', 'エラー率が通常0.1%から5%に急増し、多数のユーザーに影響'],
     'BとCがロールバック判断基準です。Bはセキュリティリスク（データ損失・漏洩）、Cは大規模なユーザー影響で、いずれも即座の対応が必要です。Aの軽微なUIバグは修正パッチで対応可能でロールバック不要、Dの10%のパフォーマンス低下は改善の余地はあるが要件を満たしており、ロールバックほどの緊急性はありません。ロールバックは「重大な影響」がある場合の最終手段であり、軽微な問題での安易なロールバックは避けるべきです。',
     4, NOW()),
    (v_lesson_id, 'multiple-choice', 'DORA Metricsで「変更のリードタイム」を短縮する最も効果的な方法はどれですか？',
     ARRAY['開発者の作業時間を増やし、コーディング速度を上げる', 'コードレビューを省略し、承認プロセスを簡素化する', 'CI/CDパイプラインを最適化し、ビルド・テスト・デプロイを自動化する', 'リリース頻度を減らし、1回のリリースに多くの変更を詰め込む'],
     ARRAY['CI/CDパイプラインを最適化し、ビルド・テスト・デプロイを自動化する'],
     'Cが正解です。リードタイム（コミット→本番稼働）を短縮するには、待ち時間とプロセスの最適化が鍵です。CI/CD自動化により、手動作業・待ち時間・承認遅延を削減できます。Aの作業時間増加は持続不可能でバーンアウトを招き、Bのレビュー省略は品質リスクを高め（変更失敗率が上がる）、Dは真逆のアプローチでリードタイムが長くなります。高パフォーマンス組織は小さく頻繁にリリースし、自動化でリードタイムを短縮しています。',
     5, NOW());

END $$;
